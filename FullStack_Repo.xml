This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
ARCHITECTURE.txt/
  ARCHITECTURE.txt
Full_Stack_Sim/
  assets/
    __init__.py/
      __init__.py
    parking_bg.png/
      parking_bg.png
    truck.png/
      truck.png
  core/
    __init__.py/
      __init__.py
    sprites.py/
      sprites.py
    ui.py/
      ui.py
  main.py/
    main.py
  settings.py/
    settings.py
  simulation/
    __init__.py/
      __init__.py
    site_conveyor_list.py/
      site_conveyor_list.py
    site_expression_tree.py/
      site_expression_tree.py
    site_parking_queue.py/
      site_parking_queue.py
    site_parking_stack.py/
      site_parking_stack.py
    site_recursion_lab.py/
      site_recursion_lab.py
    site_router_tree.py/
      site_router_tree.py
    site_sorting_floor.py/
      site_sorting_floor.py
    site_warehouse_array.py/
      site_warehouse_array.py
FullStack Project Bible.ipynb/
  FullStack Project Bible.ipynb
README.txt/
  README.txt
ROADMAP.txt/
  ROADMAP.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="ARCHITECTURE.txt/ARCHITECTURE.txt">
ARCHITECTURE GUIDELINES

1. MODULAR DESIGN
   - Core Engine (`core/`): Rendering engines (`sprites.py`) and UI system (`ui.py`).
   - Simulation Modules (`simulation/`): Self-contained "Site" files. Each site file
     encapsulates both the specific data structure logic and its corresponding
     Pygame visualization class.
   - Controller (`main.py`): A robust State Machine handling the "Facility Overview,"
     scene transitions, and global display settings (Fullscreen/Scaling).

2. LOGIC LAYER (The Backend)
   - Pure Python classes decoupled from Pygame.
   - `StackManager` / `QueueManager`: Handle LIFO/FIFO operations and return event logs.
   - `LinkedListManager`: Manages Node pointers.
   - `BSTManager` / `ExpressionTreeManager`: Handle recursive tree structures.
   - `SortingManager`: Generates step-by-step animation frames for algorithms.
   - `RecursionManager`: Solves Hanoi states.
   - `ArrayManager`: Manages fixed-size lists with explicit Read/Write receipts.

3. VISUALIZATION LAYER (The Frontend)
   - Procedural Generation:
     - All assets (buildings, trucks, terrain) are drawn via code (pygame.draw).
     - "Industrial Night Shift" Aesthetic: Dark concrete, hazard yellow markings, 
       and dynamic lighting.
   - Facility Overview (`main.py`):
     - `Facility` Class: Handles 2.5D building projection, procedural details (vents, pipes),
       and specific mechanical animations (fans, elevators, cranes).
     - Lighting System: Uses gradient alpha blending to create soft spotlights and 
       glow effects on hover.
     - Terrain: Tiled concrete generation with expansion joints, cracks, and oil stains.
   - Simulation Views:
     - Specific sprites (`ForkliftSprite`, `DroneSprite`, `GantryCrane`) handle 
       complex interpolation and state transitions (e.g., Move -> Lift -> Drop).

4. UI & INTERACTION
   - Style: Rugged Industrial Scanner (WMS Handheld).
   - Components: 
     - `HandheldChassis`: Draws the device body.
     - `LCDDisplay`: Handles text input and status messages.
     - `IndustrialLabel`: High-contrast floating labels in the Overworld.
   - Transitions:
     - "System Uplink": A fade-to-black terminal effect when switching modules 
       to simulate remote connection.
</file>

<file path="Full_Stack_Sim/assets/__init__.py/__init__.py">

</file>

<file path="Full_Stack_Sim/core/__init__.py/__init__.py">

</file>

<file path="Full_Stack_Sim/core/sprites.py/sprites.py">
import pygame
import math
import random
from settings import *
class CrateSprite(pygame.sprite.Sprite):
    def __init__(self, x, y, data_label):
        super().__init__()
        self.plate = str(data_label)
        self.pos_x = float(x)
        self.pos_y = float(y)
        self.target_x = float(x)
        self.target_y = float(y)
        self.angle = 0
        self.is_moving = False
        self.on_finish_callback = None
        self.cargo_layout = []
        for _ in range(6):
            if random.random() > 0.3:
                self.cargo_layout.append(random.choice([1, 2]))
            else:
                self.cargo_layout.append(0)
        self.original_image = self.generate_truck_surface()
        self.image = self.original_image.copy()
        self.label_surf = self.generate_label()
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)
    def generate_truck_surface(self):
        w, h = CRATE_HEIGHT, CRATE_WIDTH
        surf = pygame.Surface((w + 10, h + 10), pygame.SRCALPHA)
        ox, oy = 5, 5
        shadow_rect = pygame.Rect(ox + 4, oy + 4, w, h)
        pygame.draw.rect(surf, (0, 0, 0, 60), shadow_rect, border_radius=4)
        tire_w, tire_h = 14, 6
        pygame.draw.rect(surf, TIRE_COLOR, (ox + w - 24, oy - 2, tire_w, tire_h))
        pygame.draw.rect(surf, TIRE_COLOR, (ox + w - 24, oy + h - 4, tire_w, tire_h))
        pygame.draw.rect(surf, TIRE_COLOR, (ox + 8, oy - 2, tire_w, tire_h))
        pygame.draw.rect(surf, TIRE_COLOR, (ox + 8, oy + h - 4, tire_w, tire_h))
        bed_length = w * 0.72
        bed_rect = pygame.Rect(ox, oy, bed_length, h)
        pygame.draw.rect(surf, TRUCK_CHASSIS, bed_rect, border_radius=2)
        pygame.draw.rect(surf, (70, 70, 75), (ox, oy + 2, bed_length, h-4), 1)
        box_size = (h - 8) // 2
        start_x = ox + 2
        for i, box_type in enumerate(self.cargo_layout):
            if box_type == 0: continue
            col = i % 2
            row = i // 2
            bx = start_x + (row * (box_size + 2))
            by = oy + 4 + (col * box_size)
            color = BOX_COLOR_1 if box_type == 1 else BOX_COLOR_2
            box_rect = pygame.Rect(bx, by, box_size - 2, box_size - 2)
            pygame.draw.rect(surf, color, box_rect)
            pygame.draw.rect(surf, (0, 0, 0, 50), box_rect, 1)
            pygame.draw.line(surf, BOX_TAPE, box_rect.midleft, box_rect.midright, 2)
        pygame.draw.rect(surf, (30, 30, 30), (ox + bed_length - 2, oy + h//2 - 3, 6, 6))
        cab_x = ox + bed_length + 2
        cab_w = w - bed_length - 2
        cab_rect = pygame.Rect(cab_x, oy, cab_w, h)
        pygame.draw.rect(surf, TRUCK_CAB_WHITE, cab_rect, border_radius=3)
        ws_width = 10
        ws_height = h - 6
        ws_rect = pygame.Rect(cab_x + cab_w - 14, oy + 3, ws_width, ws_height)
        pygame.draw.rect(surf, WINDSHIELD, ws_rect, border_radius=2)
        pygame.draw.line(surf, (100, 120, 130), (ws_rect.right-2, ws_rect.top+2), (ws_rect.right-2, ws_rect.bottom-2), 1)
        pygame.draw.rect(surf, (20, 20, 20), (cab_x + cab_w - 12, oy - 2, 4, 3))
        pygame.draw.rect(surf, (20, 20, 20), (cab_x + cab_w - 12, oy + h - 1, 4, 3))
        pygame.draw.rect(surf, (255, 200, 50), (ox + w - 2, oy + 2, 2, 4))
        pygame.draw.rect(surf, (255, 200, 50), (ox + w - 2, oy + h - 6, 2, 4))
        return surf
    def generate_label(self):
        font = pygame.font.SysFont("Arial", 10, bold=True)
        raw_text = font.render(self.plate, True, (20, 20, 20))
        padding_x, padding_y = 4, 2
        w = raw_text.get_width() + padding_x * 2
        h = raw_text.get_height() + padding_y * 2
        surf = pygame.Surface((w, h))
        surf.fill((255, 255, 255))
        pygame.draw.rect(surf, (0, 0, 0), surf.get_rect(), 1)
        surf.blit(raw_text, (padding_x, padding_y))
        return surf
    def move_to(self, target_pos, callback=None):
        self.target_x, self.target_y = target_pos
        dx = self.target_x - self.pos_x
        dy = self.target_y - self.pos_y
        if abs(dx) > 1 or abs(dy) > 1:
            radians = math.atan2(-dy, dx)
            self.angle = math.degrees(radians)
        self.on_finish_callback = callback
        self.is_moving = True
    def update(self):
        if not self.is_moving: return
        dx = self.target_x - self.pos_x
        dy = self.target_y - self.pos_y
        dist = math.sqrt(dx**2 + dy**2)
        if dist < MIN_SPEED:
            self.pos_x = self.target_x
            self.pos_y = self.target_y
            self.is_moving = False
            self.angle = round(self.angle / 90) * 90
            if self.on_finish_callback:
                cb = self.on_finish_callback
                self.on_finish_callback = None
                cb()
        else:
            self.pos_x += dx * LERP_FACTOR
            self.pos_y += dy * LERP_FACTOR
            if abs(dx * LERP_FACTOR) < 0.5 and abs(dx) > 0: self.pos_x += (dx/abs(dx)) * 0.5
            if abs(dy * LERP_FACTOR) < 0.5 and abs(dy) > 0: self.pos_y += (dy/abs(dy)) * 0.5
        self.rect.center = (int(self.pos_x), int(self.pos_y))
        self.image = pygame.transform.rotate(self.original_image, self.angle)
        self.rect = self.image.get_rect(center=self.rect.center)
</file>

<file path="Full_Stack_Sim/core/ui.py/ui.py">
import pygame
import math
from settings import *
class HandheldChassis:
    def __init__(self, x, y, w, h):
        self.rect = pygame.Rect(x, y, w, h)
        self.inner_rect = self.rect.inflate(-20, -20)
    def draw(self, screen):
        shadow_rect = self.rect.copy()
        shadow_rect.y += 5
        pygame.draw.rect(screen, (20, 20, 25), shadow_rect, border_radius=30)
        pygame.draw.rect(screen, DEVICE_BODY, self.rect, border_radius=30)
        pygame.draw.rect(screen, DEVICE_HIGHLIGHT, self.rect, width=3, border_radius=30)
        self._draw_hazard_stripes(screen, self.rect.left, self.rect.top + 40, 15, self.rect.height - 80)
        self._draw_hazard_stripes(screen, self.rect.right - 15, self.rect.top + 40, 15, self.rect.height - 80)
        self._draw_bolt(screen, self.rect.left + 20, self.rect.top + 20)
        self._draw_bolt(screen, self.rect.right - 20, self.rect.top + 20)
        self._draw_bolt(screen, self.rect.left + 20, self.rect.bottom - 20)
        self._draw_bolt(screen, self.rect.right - 20, self.rect.bottom - 20)
    def _draw_hazard_stripes(self, screen, x, y, w, h):
        bg_rect = pygame.Rect(x, y, w, h)
        pygame.draw.rect(screen, STRIPE_BLACK, bg_rect)
        clip_rect = bg_rect
        screen.set_clip(clip_rect)
        stripe_width = 10
        gap = 10
        for i in range(-20, h + 20, stripe_width + gap):
            p1 = (x, y + i)
            p2 = (x + w, y + i + 10)
            p3 = (x + w, y + i + 10 + stripe_width)
            p4 = (x, y + i + stripe_width)
            pygame.draw.polygon(screen, STRIPE_YELLOW, [p1, p2, p3, p4])
        screen.set_clip(None)
        pygame.draw.rect(screen, (0,0,0), bg_rect, 2)
    def _draw_bolt(self, screen, x, y):
        pygame.draw.circle(screen, (50, 50, 50), (x, y+2), 7)
        pygame.draw.circle(screen, BOLT_COLOR, (x, y), 6)
        pygame.draw.circle(screen, (100, 100, 100), (x, y), 2)
        pygame.draw.line(screen, (100, 100, 100), (x-3, y), (x+3, y), 1)
        pygame.draw.line(screen, (100, 100, 100), (x, y-3), (x, y+3), 1)
class LCDDisplay:
    def __init__(self, x, y, w, h):
        self.rect = pygame.Rect(x, y, w, h)
        self.text = ""
        self.status_msg = "SYSTEM READY"
        self.font_large = pygame.font.SysFont("Consolas", 24, bold=True)
        self.font_small = pygame.font.SysFont("Consolas", 12)
        self.active = True
        self.cursor_blink = 0
    def handle_event(self, event):
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_BACKSPACE:
                self.text = self.text[:-1]
            elif event.key == pygame.K_RETURN:
                return self.text
            else:
                allowed_chars = ':-+*/^()'
                if event.unicode.isalnum() or event.unicode in allowed_chars:
                    self.text += event.unicode.upper()
        return None
    def update_status(self, msg):
        self.status_msg = msg
    def update(self):
        self.cursor_blink += 1
    def draw(self, screen):
        pygame.draw.rect(screen, (10, 15, 20), self.rect, border_radius=5)
        screen_rect = self.rect.inflate(-10, -10)
        pygame.draw.rect(screen, LCD_BG, screen_rect, border_radius=3)
        for i in range(screen_rect.top, screen_rect.bottom, 4):
            pygame.draw.line(screen, LCD_SCANLINE, (screen_rect.left, i), (screen_rect.right, i), 1)
        status_surf = self.font_small.render(self.status_msg, True, LCD_TEXT_DIM)
        screen.blit(status_surf, (screen_rect.x + 10, screen_rect.y + 8))
        display_text = self.text
        txt_surf = self.font_large.render(display_text, True, LCD_TEXT_MAIN)
        while txt_surf.get_width() > screen_rect.width - 10:
            display_text = display_text[1:]
            txt_surf = self.font_large.render(display_text, True, LCD_TEXT_MAIN)
        txt_x = screen_rect.left + 5
        txt_y = screen_rect.centery - 5
        screen.set_clip(screen_rect)
        screen.blit(txt_surf, (txt_x, txt_y))
        if (self.cursor_blink // 30) % 2 == 0:
            cursor_x = txt_x + txt_surf.get_width() + 2
            if cursor_x < screen_rect.right - 10:
                pygame.draw.rect(screen, LCD_TEXT_MAIN, (cursor_x, txt_y, 10, 24))
        screen.set_clip(None)
class RoundButton:
    def __init__(self, cx, cy, radius, color_base, color_light, text, callback):
        self.center = (cx, cy)
        self.radius = radius
        self.rect = pygame.Rect(cx - radius, cy - radius, radius*2, radius*2)
        self.color_base = color_base
        self.color_light = color_light
        self.text = text
        self.callback = callback
        self.font = pygame.font.SysFont("Arial", 14, bold=True)
        self.is_hovered = False
        self.is_pressed = False
    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            dx = event.pos[0] - self.center[0]
            dy = event.pos[1] - self.center[1]
            if math.sqrt(dx*dx + dy*dy) <= self.radius:
                self.is_hovered = True
            else:
                self.is_hovered = False
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.is_hovered and event.button == 1:
                self.is_pressed = True
        if event.type == pygame.MOUSEBUTTONUP:
            if self.is_pressed and self.is_hovered:
                self.is_pressed = False
                return self.callback()
            self.is_pressed = False
    def draw(self, screen):
        cx, cy = self.center
        r = self.radius
        offset_y = 4 if not self.is_pressed else 0
        pygame.draw.circle(screen, BTN_SHADOW, (cx, cy + 6), r + 2)
        pygame.draw.circle(screen, (self.color_base[0]//2, self.color_base[1]//2, self.color_base[2]//2), (cx, cy + offset_y + 4), r)
        pygame.draw.circle(screen, self.color_base, (cx, cy + offset_y), r)
        pygame.draw.circle(screen, self.color_light, (cx, cy + offset_y - 2), r - 4)
        pygame.draw.circle(screen, self.color_base, (cx, cy + offset_y + 2), r - 4)
        txt_surf = self.font.render(self.text, True, (255, 255, 255))
        txt_rect = txt_surf.get_rect(center=(cx, cy + offset_y))
        shadow_surf = self.font.render(self.text, True, (0, 0, 0, 100))
        screen.blit(shadow_surf, (txt_rect.x + 1, txt_rect.y + 1))
        screen.blit(txt_surf, txt_rect)
        if self.is_hovered and not self.is_pressed:
            pygame.draw.circle(screen, (255, 255, 255), (cx, cy + offset_y), r, 2)
class Button:
    def __init__(self, x, y, w, h, text, callback_func):
        self.rect = pygame.Rect(x, y, w, h)
        self.text = text
        self.callback = callback_func
        self.font = pygame.font.SysFont("Arial", 12, bold=True)
        self.is_hovered = False
        self.is_pressed = False
    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.is_hovered and event.button == 1:
                self.is_pressed = True
        if event.type == pygame.MOUSEBUTTONUP:
            if self.is_pressed and self.is_hovered:
                self.is_pressed = False
                return self.callback()
            self.is_pressed = False
    def draw(self, screen):
        base_color = (60, 70, 80)
        hover_color = (80, 90, 100)
        press_color = (40, 50, 60)
        color = base_color
        if self.is_hovered: color = hover_color
        if self.is_pressed: color = press_color
        shadow_rect = self.rect.copy()
        shadow_rect.y += 3
        pygame.draw.rect(screen, (30, 35, 40), shadow_rect, border_radius=3)
        btn_rect = self.rect.copy()
        if self.is_pressed:
            btn_rect.y += 2
        pygame.draw.rect(screen, color, btn_rect, border_radius=3)
        pygame.draw.rect(screen, (255, 200, 0), (btn_rect.x, btn_rect.y, 5, btn_rect.height), border_top_left_radius=3, border_bottom_left_radius=3)
        pygame.draw.line(screen, (255, 255, 255, 50), btn_rect.topleft, btn_rect.topright, 1)
        text_surf = self.font.render(self.text, True, (255, 255, 255))
        text_rect = text_surf.get_rect(center=btn_rect.center)
        screen.blit(text_surf, text_rect)
</file>

<file path="Full_Stack_Sim/main.py/main.py">
import pygame
import sys
import math
import random
from settings import *
from core.ui import Button
from simulation.site_parking_stack import ParkingStackSimulation
from simulation.site_parking_queue import ParkingQueueSimulation
from simulation.site_conveyor_list import ConveyorSimulation
from simulation.site_router_tree import RouterTreeSimulation
from simulation.site_expression_tree import ExpressionTreeSimulation
from simulation.site_sorting_floor import SortingSimulation
from simulation.site_recursion_lab import RecursionSimulation
from simulation.site_warehouse_array import ArraySimulation
COLOR_CONCRETE_DARK = (30, 32, 35)
COLOR_CONCRETE_LIGHT = (50, 52, 55)
COLOR_ASPHALT = (20, 20, 22)
COLOR_MARKING = (200, 180, 50)
COLOR_WALL_DARK = (40, 45, 50)
COLOR_WALL_LIGHT = (60, 65, 70)
COLOR_ROOF_BASE = (30, 35, 40)
class AmbientVehicle:
    def __init__(self, path, v_type, lane_id):
        self.path = path
        self.lane_id = lane_id
        self.current_point_idx = 0
        self.x, self.y = path[0]
        self.type = v_type
        self.speed = 1.5 if v_type == 'TRUCK' else 1.0
        self.angle = 0
        self.stopped = False
        self.width = 50 if v_type == 'TRUCK' else 25
        self.height = 20 if v_type == 'TRUCK' else 15
        self.original_surf = self._generate_surface()
        self.shadow_surf = self._generate_shadow()
        self.image = self.original_surf
        self.rect = self.image.get_rect(center=(self.x, self.y))
    def _generate_surface(self):
        w, h = self.width, self.height
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        if self.type == 'TRUCK':
            cab_w = w * 0.25
            pygame.draw.rect(surf, TRUCK_CAB_WHITE, (w - cab_w, 0, cab_w, h), border_radius=2)
            pygame.draw.rect(surf, (60, 70, 80), (0, 0, w - cab_w - 2, h), border_radius=2)
            pygame.draw.rect(surf, (40, 50, 60), (0, 0, w - cab_w - 2, h), 1, border_radius=2)
            pygame.draw.rect(surf, (30, 30, 30), (w - cab_w + 2, 2, 6, h-4))
            pygame.draw.rect(surf, (255, 255, 200), (w-2, 2, 2, 4))
            pygame.draw.rect(surf, (255, 255, 200), (w-2, h-6, 2, 4))
            pygame.draw.rect(surf, (200, 50, 50), (0, 2, 2, 4))
            pygame.draw.rect(surf, (200, 50, 50), (0, h-6, 2, 4))
        else:
            pygame.draw.rect(surf, (255, 200, 0), (0, 0, w-8, h), border_radius=3)
            pygame.draw.rect(surf, (40, 40, 40), (5, 2, 10, h-4), 1)
            pygame.draw.rect(surf, (100, 100, 100), (w-8, 2, 8, 2))
            pygame.draw.rect(surf, (100, 100, 100), (w-8, h-4, 8, 2))
        return surf
    def _generate_shadow(self):
        w, h = self.width, self.height
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        pygame.draw.rect(surf, (0, 0, 0, 80), (0, 0, w, h), border_radius=4)
        return surf
    def update(self, all_vehicles):
        target = self.path[self.current_point_idx]
        dx = target[0] - self.x
        dy = target[1] - self.y
        dist = math.hypot(dx, dy)
        if dist > 0:
            dir_x = dx / dist
            dir_y = dy / dist
        else:
            dir_x, dir_y = 0, 0
        self.stopped = False
        lookahead = 70
        for v in all_vehicles:
            if v is self: continue
            if v.lane_id != self.lane_id: continue
            to_v_x = v.x - self.x
            to_v_y = v.y - self.y
            dist_to_v = math.hypot(to_v_x, to_v_y)
            if dist_to_v < lookahead:
                dot = (to_v_x * dir_x) + (to_v_y * dir_y)
                if dot > 0.7 * dist_to_v:
                    self.stopped = True
                    break
        if not self.stopped:
            if dist < self.speed:
                self.current_point_idx = (self.current_point_idx + 1) % len(self.path)
            else:
                self.x += dir_x * self.speed
                self.y += dir_y * self.speed
                self.angle = -math.degrees(math.atan2(dy, dx))
    def draw(self, screen):
        rotated_img = pygame.transform.rotate(self.original_surf, self.angle)
        rotated_shadow = pygame.transform.rotate(self.shadow_surf, self.angle)
        rect = rotated_img.get_rect(center=(self.x, self.y))
        shadow_rect = rotated_shadow.get_rect(center=(self.x + 5, self.y + 5))
        screen.blit(rotated_shadow, shadow_rect)
        screen.blit(rotated_img, rect)
        if self.type == 'TRUCK':
            rad = math.radians(self.angle)
            front_x = self.x + math.cos(rad) * (self.width/2)
            front_y = self.y - math.sin(rad) * (self.width/2)
            beam_len = 60
            p1 = (front_x, front_y)
            p2 = (front_x + math.cos(rad - 0.3) * beam_len, front_y - math.sin(rad - 0.3) * beam_len)
            p3 = (front_x + math.cos(rad + 0.3) * beam_len, front_y - math.sin(rad + 0.3) * beam_len)
            gfx_surf = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
            pygame.draw.polygon(gfx_surf, (255, 255, 200, 30), [p1, p2, p3])
            screen.blit(gfx_surf, (0,0))
class IndustrialLabel:
    def __init__(self, x, y, title, subtitle):
        self.x = x
        self.y = y
        self.title = title.upper()
        self.subtitle = subtitle.upper()
        self.font_head = pygame.font.SysFont("Impact", 16)
        self.font_sub = pygame.font.SysFont("Arial", 10, bold=True)
        self.alpha = 0
    def draw(self, screen, hovered):
        target = 255 if hovered else 150
        self.alpha += (target - self.alpha) * 0.1
        t_surf = self.font_head.render(self.title, True, (255, 255, 255))
        s_surf = self.font_sub.render(self.subtitle, True, (255, 200, 0))
        w = max(t_surf.get_width(), s_surf.get_width()) + 20
        h = 40
        bg_rect = pygame.Rect(self.x - w//2, self.y - h - 10, w, h)
        s_rect = bg_rect.copy()
        s_rect.y += 4
        s_surf_bg = pygame.Surface((w, h), pygame.SRCALPHA)
        pygame.draw.rect(s_surf_bg, (0, 0, 0, 100), s_surf_bg.get_rect(), border_radius=4)
        screen.blit(s_surf_bg, s_rect)
        plate_surf = pygame.Surface((w, h), pygame.SRCALPHA)
        plate_alpha = int(self.alpha)
        pygame.draw.rect(plate_surf, (20, 25, 30, plate_alpha), (0, 0, w, h), border_radius=4)
        pygame.draw.rect(plate_surf, (100, 100, 100, plate_alpha), (0, 0, w, h), 1, border_radius=4)
        pygame.draw.rect(plate_surf, (255, 200, 0, plate_alpha), (0, 0, 4, h), border_top_left_radius=4, border_bottom_left_radius=4)
        plate_surf.blit(t_surf, (10, 4))
        plate_surf.blit(s_surf, (10, 22))
        screen.blit(plate_surf, bg_rect)
        if hovered:
            start = (self.x, self.y)
            end = (self.x, bg_rect.bottom)
            pygame.draw.line(screen, (255, 255, 255), start, end, 1)
            pygame.draw.circle(screen, (255, 255, 255), start, 2)
class Facility:
    def __init__(self, x, y, w, h, title, subtitle, type_id, callback):
        self.rect = pygame.Rect(x, y, w, h)
        self.base_y = y
        self.title = title
        self.subtitle = subtitle
        self.type_id = type_id
        self.callback = callback
        self.hovered = False
        self.anim_timer = 0
        self.label = IndustrialLabel(self.rect.centerx, self.rect.top - 5, title, subtitle)
        self.wall_color = COLOR_WALL_DARK
        self.roof_color = COLOR_ROOF_BASE
        self.accent_color = (255, 100, 0)
        if type_id in ["STACK", "QUEUE"]: self.accent_color = (255, 200, 0)
        if type_id in ["CONVEYOR", "SORTING"]: self.accent_color = (0, 150, 255)
        if type_id in ["TREE", "EXPR_TREE"]: self.accent_color = (0, 255, 100)
        if type_id in ["RECURSION", "ARRAY"]: self.accent_color = (255, 50, 50)
    def update(self):
        mouse_pos = pygame.mouse.get_pos()
        self.hovered = self.rect.collidepoint(mouse_pos)
        if self.hovered:
            self.anim_timer += 1
    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.hovered:
                self.callback()
    def draw(self, screen):
        shadow_offset = 15
        shadow_points = [
            self.rect.bottomleft,
            (self.rect.left + shadow_offset, self.rect.bottom - shadow_offset),
            (self.rect.right + shadow_offset, self.rect.bottom - shadow_offset),
            (self.rect.right + shadow_offset, self.rect.top - shadow_offset),
            self.rect.topright
        ]
        shadow_surf = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        pygame.draw.polygon(shadow_surf, (0, 0, 0, 120), shadow_points)
        screen.blit(shadow_surf, (0,0))
        pad_rect = self.rect.inflate(20, 20)
        pygame.draw.rect(screen, COLOR_CONCRETE_LIGHT, pad_rect, border_radius=4)
        pygame.draw.rect(screen, (20, 20, 20), pad_rect, 1, border_radius=4)
        depth = 10
        pygame.draw.polygon(screen, (30, 30, 35), [
            self.rect.topright,
            (self.rect.right + depth, self.rect.top - depth),
            (self.rect.right + depth, self.rect.bottom - depth),
            self.rect.bottomright
        ])
        pygame.draw.polygon(screen, (50, 50, 55), [
            self.rect.topleft,
            (self.rect.left + depth, self.rect.top - depth),
            (self.rect.right + depth, self.rect.top - depth),
            self.rect.topright
        ])
        roof_rect = pygame.Rect(self.rect.left + depth, self.rect.top - depth, self.rect.width, self.rect.height)
        pygame.draw.rect(screen, self.roof_color, roof_rect)
        for i in range(roof_rect.left, roof_rect.right, 10):
            pygame.draw.line(screen, (0, 0, 0, 50), (i, roof_rect.top), (i, roof_rect.bottom), 1)
        self._draw_mechanics(screen, roof_rect)
        if self.hovered:
            glow_radius = 150
            glow_surf = pygame.Surface((glow_radius * 2, glow_radius * 2), pygame.SRCALPHA)
            num_layers = 15
            for i in range(num_layers):
                radius = int(glow_radius * (1 - i/num_layers))
                alpha = int(10 + (i * 2))
                if alpha > 60: alpha = 60
                pygame.draw.circle(glow_surf, (*self.accent_color, alpha), (glow_radius, glow_radius), radius)
            screen.blit(glow_surf, (roof_rect.centerx - glow_radius, roof_rect.centery - glow_radius))
            pygame.draw.rect(screen, self.accent_color, roof_rect, 2)
            pygame.draw.rect(screen, (255, 255, 255), roof_rect, 1)
        self.label.draw(screen, self.hovered)
    def _draw_mechanics(self, screen, rect):
        cx, cy = rect.center
        if self.type_id == "STACK":
            shaft_w = 30
            pygame.draw.rect(screen, (20, 20, 20), (cx - shaft_w//2, rect.top + 10, shaft_w, rect.height - 20))
            offset = abs(math.sin(self.anim_timer * 0.05)) * (rect.height - 40)
            plat_y = rect.bottom - 20 - offset
            plat_color = self.accent_color if self.hovered else (40, 40, 40)
            pygame.draw.rect(screen, plat_color, (cx - 12, plat_y, 24, 8))
        elif self.type_id == "QUEUE":
            for y in [rect.top + 20, rect.bottom - 20]:
                pygame.draw.line(screen, (50, 50, 50), (rect.left, y), (rect.right, y), 6)
                if self.hovered:
                    offset = (self.anim_timer * 2) % 20
                    for x in range(rect.left, rect.right, 20):
                        lx = x + offset
                        if lx < rect.right:
                            pygame.draw.circle(screen, self.accent_color, (lx, y), 2)
        elif self.type_id == "CONVEYOR":
            for gx in [cx - 30, cx, cx + 30]:
                pygame.draw.circle(screen, (60, 60, 60), (gx, cy), 12)
                if self.hovered:
                    angle = self.anim_timer * 0.1
                    end_x = gx + math.cos(angle) * 12
                    end_y = cy + math.sin(angle) * 12
                    pygame.draw.line(screen, (100, 100, 100), (gx, cy), (end_x, end_y), 2)
        elif self.type_id == "TREE":
            pygame.draw.line(screen, (50, 50, 50), (cx, rect.top), (cx, rect.bottom), 4)
            pygame.draw.line(screen, (50, 50, 50), (rect.left, cy), (rect.right, cy), 4)
            if self.hovered:
                offset = (self.anim_timer * 2) % (rect.height // 2)
                pygame.draw.circle(screen, self.accent_color, (cx, cy - offset), 3)
                pygame.draw.circle(screen, self.accent_color, (cx, cy + offset), 3)
        elif self.type_id == "EXPR_TREE":
            pygame.draw.rect(screen, (40, 40, 40), (cx - 20, cy - 20, 40, 40))
            pygame.draw.rect(screen, (20, 20, 20), (cx - 20, cy - 20, 40, 40), 2)
            if self.hovered:
                if (self.anim_timer // 10) % 2 == 0:
                    pygame.draw.rect(screen, self.accent_color, (cx - 15, cy - 15, 10, 10))
                    pygame.draw.rect(screen, self.accent_color, (cx + 5, cy + 5, 10, 10))
                else:
                    pygame.draw.rect(screen, self.accent_color, (cx + 5, cy - 15, 10, 10))
                    pygame.draw.rect(screen, self.accent_color, (cx - 15, cy + 5, 10, 10))
        elif self.type_id == "SORTING":
            pygame.draw.line(screen, (80, 80, 80), (rect.left, rect.top + 10), (rect.right, rect.top + 10), 2)
            pygame.draw.line(screen, (80, 80, 80), (rect.left, rect.bottom - 10), (rect.right, rect.bottom - 10), 2)
            crane_x = rect.left + 10 + abs(math.sin(self.anim_timer * 0.05)) * (rect.width - 40)
            crane_color = self.accent_color if self.hovered else (40, 40, 40)
            pygame.draw.rect(screen, crane_color, (crane_x, rect.top + 5, 10, rect.height - 10))
        elif self.type_id == "ARRAY":
            rows, cols = 3, 6
            cell_w = rect.width / cols
            cell_h = rect.height / rows
            for r in range(rows):
                for c in range(cols):
                    bx = rect.left + c * cell_w + 2
                    by = rect.top + r * cell_h + 2
                    pygame.draw.rect(screen, (40, 40, 45), (bx, by, cell_w - 4, cell_h - 4))
                    if (r * c + r) % 3 == 0:
                         pygame.draw.rect(screen, (60, 70, 80), (bx+2, by+2, cell_w - 8, cell_h - 8))
            if self.hovered:
                scan_x = rect.left + abs(math.sin(self.anim_timer * 0.05)) * rect.width
                pygame.draw.line(screen, (255, 0, 0), (scan_x, rect.top), (scan_x, rect.bottom), 2)
        elif self.type_id == "RECURSION":
            pygame.draw.circle(screen, (40, 40, 40), (cx, cy), 25, 2)
            pygame.draw.circle(screen, (40, 40, 40), (cx, cy), 15, 2)
            if self.hovered:
                angle = self.anim_timer * 0.1
                ox = cx + math.cos(angle) * 25
                oy = cy + math.sin(angle) * 25
                pygame.draw.line(screen, self.accent_color, (cx, cy), (ox, oy), 2)
class MainMenu:
    def __init__(self, screen, switch_callback, fullscreen_callback):
        self.screen = screen
        self.switch_callback = switch_callback
        self.fullscreen_callback = fullscreen_callback
        self.bg_surface = self._generate_map_background()
        self.transitioning = False
        self.transition_alpha = 0
        self.target_scene = None
        self.facilities = [
            Facility(80, 130, 80, 140, "Stack Tower", "LIFO Operations", "STACK", lambda: self.start_transition("STACK")),
            Facility(250, 150, 180, 80, "Weigh Station", "FIFO Queue", "QUEUE", lambda: self.start_transition("QUEUE")),
            Facility(520, 130, 150, 100, "Conveyor Belt", "Linked List", "CONVEYOR", lambda: self.start_transition("CONVEYOR")),
            Facility(120, 350, 120, 120, "Routing Hub", "Binary Search Tree", "TREE", lambda: self.start_transition("TREE")),
            Facility(450, 350, 120, 120, "Parser Lab", "Expression Tree", "EXPR_TREE", lambda: self.start_transition("EXPR_TREE")),
            Facility(80, 550, 200, 100, "Sorting Yard", "Algorithms", "SORTING", lambda: self.start_transition("SORTING")),
            Facility(350, 570, 100, 80, "Recursion", "Hanoi Crane", "RECURSION", lambda: self.start_transition("RECURSION")),
            Facility(550, 550, 200, 80, "Smart Rack", "Array Storage", "ARRAY", lambda: self.start_transition("ARRAY")),
        ]
        self.exit_btn = Button(SCREEN_WIDTH - 120, SCREEN_HEIGHT - 50, 100, 30, "LOGOUT", lambda: self.switch_callback("QUIT"))
        self.fs_btn = Button(SCREEN_WIDTH - 120, SCREEN_HEIGHT - 90, 100, 30, "FULLSCREEN", self.fullscreen_callback)
        self.lanes = [
            [(95, 245), (625, 245), (625, 555), (95, 555)],
            [(145, 505), (575, 505), (575, 295), (145, 295)]
        ]
        self.vehicles = []
        for _ in range(6):
            self._spawn_vehicle()
    def _spawn_vehicle(self):
        v_type = random.choice(['TRUCK', 'FORKLIFT'])
        lane_idx = random.randint(0, 1)
        path = self.lanes[lane_idx]
        start_idx = random.randint(0, 3)
        new_v = AmbientVehicle(path, v_type, lane_idx)
        next_idx = (start_idx + 1) % 4
        new_v.current_point_idx = next_idx
        p1 = path[start_idx]
        p2 = path[next_idx]
        t = random.random()
        new_v.x = p1[0] + (p2[0] - p1[0]) * t
        new_v.y = p1[1] + (p2[1] - p1[1]) * t
        safe = True
        for v in self.vehicles:
            if v.lane_id == lane_idx and math.hypot(v.x - new_v.x, v.y - new_v.y) < 80:
                safe = False
                break
        if safe:
            self.vehicles.append(new_v)
    def _draw_painted_text(self, target_surf, text, x, y, font_size, align='left', font_name="Impact"):
        font = pygame.font.SysFont(font_name, font_size)
        text_surf = font.render(text, True, (220, 220, 220))
        w, h = text_surf.get_size()
        texture_surf = pygame.Surface((w, h), pygame.SRCALPHA)
        texture_surf.blit(text_surf, (0, 0))
        texture_surf.lock()
        for _ in range(int(w * h * 0.15)):
            nx = random.randint(0, w-1)
            ny = random.randint(0, h-1)
            if texture_surf.get_at((nx, ny))[3] > 0:
                texture_surf.set_at((nx, ny), (0, 0, 0, 0))
        texture_surf.unlock()
        texture_surf.set_alpha(160)
        if align == 'right':
            dest_x = x - w
        else:
            dest_x = x
        target_surf.blit(texture_surf, (dest_x, y))
    def _generate_map_background(self):
        surf = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        surf.fill(COLOR_CONCRETE_DARK)
        tile_w, tile_h = 100, 80
        for y in range(0, SCREEN_HEIGHT, tile_h):
            for x in range(0, SCREEN_WIDTH, tile_w):
                base_val = random.randint(28, 35)
                color = (base_val, base_val + 2, base_val + 5)
                pygame.draw.rect(surf, color, (x, y, tile_w, tile_h))
                pygame.draw.line(surf, (20, 22, 25), (x, y), (x + tile_w, y), 2)
                pygame.draw.line(surf, (20, 22, 25), (x, y), (x, y + tile_h), 2)
                if random.random() > 0.8:
                    cx, cy = x + random.randint(20, 80), y + random.randint(20, 60)
                    points = [(cx, cy)]
                    for _ in range(3):
                        cx += random.randint(-10, 10)
                        cy += random.randint(-10, 10)
                        points.append((cx, cy))
                    pygame.draw.lines(surf, (25, 25, 25), False, points, 1)
        for _ in range(20):
            sx = random.randint(0, SCREEN_WIDTH)
            sy = random.randint(0, SCREEN_HEIGHT)
            w = random.randint(30, 80)
            h = random.randint(20, 50)
            stain = pygame.Surface((w, h), pygame.SRCALPHA)
            pygame.draw.ellipse(stain, (10, 10, 10, 30), (0, 0, w, h))
            surf.blit(stain, (sx, sy))
        road_color = COLOR_ASPHALT
        points = [(120, 270), (600, 270), (600, 530), (120, 530)]
        pygame.draw.lines(surf, road_color, True, points, 100)
        segments = [
            ((120, 270), (600, 270)),
            ((600, 270), (600, 530)),
            ((600, 530), (120, 530)),
            ((120, 530), (120, 270))
        ]
        for p1, p2 in segments:
            dx = p2[0] - p1[0]
            dy = p2[1] - p1[1]
            dist = math.hypot(dx, dy)
            steps = int(dist / 40)
            for i in range(steps):
                t1 = i / steps
                t2 = (i + 0.5) / steps
                sx = p1[0] + dx * t1
                sy = p1[1] + dy * t1
                ex = p1[0] + dx * t2
                ey = p1[1] + dy * t2
                pygame.draw.line(surf, (200, 200, 200), (sx, sy), (ex, ey), 2)
        connectors = [
            ((120, 270), (120, 200)),
            ((340, 270), (340, 200)),
            ((600, 270), (600, 200)),
            ((180, 270), (180, 350)),
            ((510, 270), (510, 350)),
            ((180, 530), (180, 600)),
            ((400, 530), (400, 600)),
            ((600, 530), (600, 600)),
        ]
        for p1, p2 in connectors:
            pygame.draw.line(surf, road_color, p1, p2, 40)
        for p1, p2 in connectors:
            pygame.draw.line(surf, COLOR_MARKING, p1, p2, 2)
        self._draw_painted_text(surf, "FullStack.", 960, 245, 75, align='right', font_name="Impact")
        names = ["Llegue", "Monreal", "Odrunia", "Revidad"]
        start_y = 340
        for name in names:
            self._draw_painted_text(surf, name, 955, start_y, 20, align='right', font_name="Impact")
            start_y += 28
        for _ in range(20000):
            x = random.randint(0, SCREEN_WIDTH-1)
            y = random.randint(0, SCREEN_HEIGHT-1)
            c = random.randint(0, 10)
            current = surf.get_at((x,y))
            new_c = (max(0, current.r - c), max(0, current.g - c), max(0, current.b - c))
            surf.set_at((x, y), new_c)
        vig = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        pygame.draw.rect(vig, (0,0,0,0), vig.get_rect())
        for i in range(100):
            pygame.draw.rect(vig, (0,0,0, 2), (i*4, i*3, SCREEN_WIDTH - i*8, SCREEN_HEIGHT - i*6), 10)
        surf.blit(vig, (0,0))
        return surf
    def start_transition(self, scene_name):
        if not self.transitioning:
            self.transitioning = True
            self.target_scene = scene_name
            self.transition_alpha = 0
    def handle_events(self, event):
        if self.transitioning:
            return
        for fac in self.facilities:
            fac.handle_event(event)
        self.exit_btn.handle_event(event)
        self.fs_btn.handle_event(event)
    def update(self):
        for fac in self.facilities:
            fac.update()
        for v in self.vehicles:
            v.update(self.vehicles)
        if len(self.vehicles) < 8 and random.random() < 0.01:
            self._spawn_vehicle()
        if self.transitioning:
            self.transition_alpha += 10
            if self.transition_alpha >= 255:
                self.transition_alpha = 255
                self.switch_callback(self.target_scene)
    def draw(self):
        self.screen.blit(self.bg_surface, (0, 0))
        for v in self.vehicles:
            v.draw(self.screen)
        for fac in self.facilities:
            fac.draw(self.screen)
        self.exit_btn.draw(self.screen)
        self.fs_btn.draw(self.screen)
        pygame.draw.rect(self.screen, (0, 0, 0), (0, 0, SCREEN_WIDTH, 40))
        pygame.draw.line(self.screen, (255, 200, 0), (0, 40), (SCREEN_WIDTH, 40), 2)
        font = pygame.font.SysFont("Impact", 20)
        title = font.render("FULL STACK LOGISTICS // DATA STRUCTURES AND ALGORITHMS", True, (200, 200, 200))
        self.screen.blit(title, (20, 8))
        pygame.draw.circle(self.screen, (0, 255, 0), (SCREEN_WIDTH - 30, 20), 5)
        status = pygame.font.SysFont("Arial", 10).render("LIVE FEED", True, (0, 255, 0))
        self.screen.blit(status, (SCREEN_WIDTH - 90, 15))
        hint = pygame.font.SysFont("Arial", 10).render("[F11] FULL SCREEN", True, (100, 100, 100))
        self.screen.blit(hint, (SCREEN_WIDTH - 180, 15))
        if self.transitioning:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            overlay.fill((0, 0, 0))
            overlay.set_alpha(self.transition_alpha)
            self.screen.blit(overlay, (0, 0))
            if self.transition_alpha > 100:
                font_term = pygame.font.SysFont("Consolas", 24, bold=True)
                text = font_term.render(f"ESTABLISHING UPLINK TO {self.target_scene}...", True, (0, 255, 0))
                self.screen.blit(text, (SCREEN_WIDTH//2 - text.get_width()//2, SCREEN_HEIGHT//2))
def main():
    pygame.init()
    flags = pygame.SCALED
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), flags)
    pygame.display.set_caption("Full Stack Logistics Simulator")
    clock = pygame.time.Clock()
    current_scene = None
    is_fullscreen = False
    def toggle_fullscreen():
        nonlocal is_fullscreen, screen
        is_fullscreen = not is_fullscreen
        if is_fullscreen:
            screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SCALED | pygame.FULLSCREEN)
        else:
            screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SCALED)
        if current_scene:
            current_scene.screen = screen
    def switch_scene(scene_name):
        nonlocal current_scene
        if scene_name == "MENU":
            current_scene = MainMenu(screen, switch_scene, toggle_fullscreen)
        elif scene_name in ["STACK", "QUEUE", "CONVEYOR", "TREE", "EXPR_TREE", "SORTING", "RECURSION", "ARRAY"]:
            if scene_name == "STACK":
                current_scene = ParkingStackSimulation(screen)
            elif scene_name == "QUEUE":
                current_scene = ParkingQueueSimulation(screen)
            elif scene_name == "CONVEYOR":
                current_scene = ConveyorSimulation(screen)
            elif scene_name == "TREE":
                current_scene = RouterTreeSimulation(screen)
            elif scene_name == "EXPR_TREE":
                current_scene = ExpressionTreeSimulation(screen)
            elif scene_name == "SORTING":
                current_scene = SortingSimulation(screen)
            elif scene_name == "RECURSION":
                current_scene = RecursionSimulation(screen)
            elif scene_name == "ARRAY":
                current_scene = ArraySimulation(screen)
            back_btn = Button(10, 10, 100, 30, "< MAP", lambda: switch_scene("MENU"))
            original_handle = current_scene.handle_events
            original_draw = current_scene.draw
            def new_handle(event):
                back_btn.handle_event(event)
                original_handle(event)
            def new_draw():
                original_draw()
                back_btn.draw(screen)
            current_scene.handle_events = new_handle
            current_scene.draw = new_draw
        elif scene_name == "QUIT":
            pygame.quit()
            sys.exit()
    switch_scene("MENU")
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_F11:
                    toggle_fullscreen()
            if current_scene:
                current_scene.handle_events(event)
        if current_scene:
            current_scene.update()
            current_scene.draw()
        pygame.display.flip()
        clock.tick(FPS)
    pygame.quit()
    sys.exit()
if __name__ == "__main__":
    main()
</file>

<file path="Full_Stack_Sim/settings.py/settings.py">
import pygame
import os
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
ASSETS_DIR = os.path.join(BASE_DIR, 'assets')
SCREEN_WIDTH = 1000
SCREEN_HEIGHT = 700
FPS = 60
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
DEVICE_BODY      = (60, 65, 70)
DEVICE_BEZEL     = (30, 35, 40)
DEVICE_HIGHLIGHT = (90, 95, 100)
BOLT_COLOR       = (180, 180, 185)
STRIPE_YELLOW    = (255, 190, 0)
STRIPE_BLACK     = (20, 20, 20)
LCD_BG           = (0, 40, 40)
LCD_TEXT_MAIN    = (50, 255, 200)
LCD_TEXT_DIM     = (0, 150, 120)
LCD_SCANLINE     = (0, 20, 20)
BTN_GREEN_BASE   = (0, 160, 60)
BTN_GREEN_LIGHT  = (50, 200, 100)
BTN_ALT_GREEN_BASE = (0, 180, 100)
BTN_ALT_GREEN_LIGHT = (50, 220, 140)
BTN_RED_BASE     = (180, 40, 40)
BTN_RED_LIGHT    = (220, 80, 80)
BTN_BLUE_BASE    = (40, 100, 180)
BTN_BLUE_LIGHT   = (80, 140, 220)
BTN_SHADOW       = (20, 25, 30)
YARD_CONCRETE    = (130, 130, 135)
YARD_NOISE_1     = (120, 120, 125)
YARD_NOISE_2     = (140, 140, 145)
ASPHALT_BASE     = (60, 60, 65)
ASPHALT_DARK     = (40, 40, 45)
TIRE_MARKS       = (30, 30, 35)
ROAD_STRIPE      = (200, 200, 200)
BRICK_RED        = (130, 70, 60)
BRICK_DETAIL     = (110, 50, 40)
ROOF_TAR         = (50, 50, 55)
WAREHOUSE_WALL   = (180, 185, 190)
WAREHOUSE_ROOF   = (100, 105, 110)
BOLLARD_YELLOW   = (220, 180, 20)
SHADOW_COLOR     = (0, 0, 0, 60)
CONTAINER_RED    = (160, 50, 40)
CONTAINER_BLUE   = (40, 80, 140)
CONTAINER_GREEN  = (50, 100, 60)
CONTAINER_RIB    = (0, 0, 0, 50)
BARREL_BLUE      = (30, 60, 100)
BARREL_RIM       = (150, 150, 160)
FENCE_COLOR      = (180, 180, 180)
FENCE_SHADOW     = (0, 0, 0, 80)
DRAIN_METAL      = (70, 70, 75)
OIL_STAIN        = (30, 30, 30, 100)
CRACK_COLOR      = (80, 80, 85)
FLOOR_COLOR = (115, 118, 122)
WALL_TOP_COLOR = (210, 215, 220)
WALL_SIDE_COLOR = (80, 85, 90)
PARKING_LINE_COLOR = (240, 240, 245)
ASPHALT_STACK_BASE = (70, 72, 75)
ASPHALT_STACK_NOISE = (60, 62, 65)
WALL_CORRUGATED_DARK = (50, 55, 60)
WALL_CORRUGATED_LIGHT = (65, 70, 75)
CONTROL_ROOM_GLOW = (180, 220, 230, 50)
STENCIL_TEXT_COLOR = (255, 255, 255, 60)
TRUCK_CAB_WHITE = (245, 245, 250)
TRUCK_CHASSIS = (50, 50, 55)
WINDSHIELD = (40, 44, 50)
TIRE_COLOR = (20, 20, 20)
BOX_COLOR_1 = (205, 133, 63)
BOX_COLOR_2 = (222, 184, 135)
BOX_TAPE    = (190, 120, 50)
CRATE_WIDTH = 45
CRATE_HEIGHT = 90
PARKING_GAP = 10
LERP_FACTOR = 0.12
MIN_SPEED = 1.5
SPAWN_X = -100
SPAWN_Y = SCREEN_HEIGHT - CRATE_HEIGHT - 40
RECEIVING_BAY_X = 100
RECEIVING_BAY_Y = SCREEN_HEIGHT - CRATE_HEIGHT - 40
STACK_ZONE_X = 300
STACK_ZONE_BASE_Y = SCREEN_HEIGHT - 60
HOLDING_ZONE_X = 550
HOLDING_ZONE_Y = SCREEN_HEIGHT - 60
SHIPPING_BAY_X = -150
SHIPPING_BAY_Y = SCREEN_HEIGHT - CRATE_HEIGHT - 250
WAREHOUSE_PILLAR = (110, 120, 125)
SHELF_COLOR = (180, 140, 100)
CEILING_TRUSS = (70, 75, 80)
FLUORESCENT_LIGHT = (220, 230, 240)
HOPPER_METAL = (140, 145, 150)
HOPPER_SHADOW = (100, 105, 110)
CONCRETE_NOISE_1 = (110, 113, 117)
CONCRETE_NOISE_2 = (120, 123, 127)
WALL_BASE_COLOR = (130, 135, 140)
WALL_LINE_COLOR = (120, 125, 130)
LIGHT_RAY_COLOR = (255, 255, 220, 20)
STATIC_SHADOW_COLOR = (0, 0, 0, 40)
</file>

<file path="Full_Stack_Sim/simulation/__init__.py/__init__.py">

</file>

<file path="Full_Stack_Sim/simulation/site_conveyor_list.py/site_conveyor_list.py">
import pygame
import random
from settings import *
from core.sprites import CrateSprite
from core.ui import HandheldChassis, LCDDisplay, RoundButton
BOX_SIZES = { 'small': (40, 40), 'medium': (60, 50), 'large': (80, 60) }
class BoxSprite(CrateSprite):
    def __init__(self, x, y, data_label, size_type='medium'):
        self.size_type = size_type; self.width, self.height = BOX_SIZES[self.size_type]
        super().__init__(x, y, data_label)
        self.plate = str(data_label); self.is_dropping = False; self.is_bouncing = False
        self.drop_speed = 0; self.gravity = 0.4; self.bounce_speed = -5; self.target_y_for_drop = 0
        self.drop_callback = None; self.original_image = self.generate_box_surface()
        self.image = self.original_image.copy(); self.rect = self.image.get_rect(center=(x, y))
    def generate_box_surface(self):
        surf = pygame.Surface((self.width + 6, self.height + 6), pygame.SRCALPHA)
        pygame.draw.rect(surf, (0, 0, 0, 60), (5, 5, self.width, self.height), border_radius=4)
        box_rect = pygame.Rect(2, 2, self.width, self.height)
        pygame.draw.rect(surf, BOX_COLOR_1, box_rect, border_radius=4)
        pygame.draw.rect(surf, (0,0,0, 40), box_rect, 2)
        pygame.draw.line(surf, BOX_TAPE, (box_rect.centerx, box_rect.top), (box_rect.centerx, box_rect.bottom), 15)
        label_w, label_h = self.label_surf.get_size()
        label_x = (surf.get_width() - label_w) / 2; label_y = (surf.get_height() - label_h) / 2
        surf.blit(self.label_surf, (label_x, label_y)); return surf
    def drop_to(self, target_y, callback):
        self.is_dropping = True; self.target_y_for_drop = target_y; self.drop_callback = callback
    def update(self):
        if self.is_dropping:
            self.drop_speed += self.gravity; self.pos_y += self.drop_speed
            if self.pos_y >= self.target_y_for_drop: self.pos_y = self.target_y_for_drop; self.is_dropping = False; self.is_bouncing = True
            self.rect.centery = int(self.pos_y)
        elif self.is_bouncing:
            self.pos_y += self.bounce_speed; self.bounce_speed += self.gravity
            if self.pos_y >= self.target_y_for_drop:
                self.pos_y = self.target_y_for_drop; self.is_bouncing = False
                if self.drop_callback: cb = self.drop_callback; self.drop_callback = None; cb()
            self.rect.centery = int(self.pos_y)
        elif self.is_moving:
            dx = self.target_x - self.pos_x; dy = self.target_y - self.pos_y
            if (dx**2 + dy**2)**0.5 < MIN_SPEED:
                self.pos_x, self.pos_y = self.target_x, self.target_y; self.is_moving = False
                if self.on_finish_callback: cb = self.on_finish_callback; self.on_finish_callback = None; cb()
            else: self.pos_x += dx * LERP_FACTOR; self.pos_y += dy * LERP_FACTOR
            self.rect.center = (int(self.pos_x), int(self.pos_y))
        self.image = self.original_image
class Node:
    def __init__(self, label): self.label = label; self.next = None
class LinkedListManager:
    def __init__(self, capacity=10): self.head = None; self.size = 0; self.capacity = capacity
    def is_full(self): return self.size >= self.capacity
    def insert_at(self, index, label):
        if self.is_full(): return {"type": "ERROR", "message": "CONVEYOR FULL"}
        if index < 0 or index > self.size: return {"type": "ERROR", "message": "INVALID INDEX"}
        new_node = Node(label)
        if index == 0: new_node.next = self.head; self.head = new_node
        else:
            current = self.head
            for _ in range(index - 1): current = current.next
            new_node.next = current.next; current.next = new_node
        self.size += 1; return {"type": "INSERT", "label": label, "index": index}
    def remove_box(self, label):
        if not self.head: return [{"type": "ERROR", "message": "CONVEYOR EMPTY"}]
        if self.head.label == label:
            self.head = self.head.next; self.size -= 1
            return [{"type": "REMOVE", "label": label, "index": 0}]
        current = self.head; index = 0
        while current.next and current.next.label != label: current = current.next; index += 1
        if current.next:
            removed_node = current.next; current.next = removed_node.next; self.size -= 1
            return [{"type": "REMOVE", "label": removed_node.label, "index": index + 1}]
        return [{"type": "ERROR", "message": "NOT FOUND"}]
    def find_box(self, label):
        current = self.head
        while current:
            if current.label == label: return True
            current = current.next
        return False
class ConveyorSimulation:
    def __init__(self, screen):
        self.screen = screen; self.logic = LinkedListManager(capacity=10)
        self.all_sprites = pygame.sprite.Group(); self.crates_group = pygame.sprite.Group()
        self.placement_mode = False; self.label_to_place = ""; self.placement_markers = []
        self.ui_x = 750; self.ui_w = 250
        self.chassis = HandheldChassis(self.ui_x + 10, 20, self.ui_w - 20, SCREEN_HEIGHT - 40)
        self.lcd = LCDDisplay(self.ui_x + 35, 80, self.ui_w - 70, 100)
        self.lcd.update_status("CONVEYOR OPS")
        btn_cx = self.ui_x + self.ui_w // 2
        self.btn_append = RoundButton(btn_cx, 260, 40, BTN_GREEN_BASE, BTN_GREEN_LIGHT, "APPEND", self.action_append)
        self.btn_insert = RoundButton(btn_cx, 350, 40, BTN_BLUE_BASE, BTN_BLUE_LIGHT, "INSERT AT", self.action_insert_at)
        self.btn_remove = RoundButton(btn_cx, 440, 40, BTN_RED_BASE, BTN_RED_LIGHT, "REMOVE", self.action_remove)
        self.visual_list = []; self.is_animating = False; self.animation_lock_count = 0
        self.BELT_Y = SCREEN_HEIGHT - 100; self.SIMULATION_WIDTH = 750
        self.HOPPER_X = self.SIMULATION_WIDTH / 2; self.HOPPER_Y = -100
        self.DESPAWN_POINT = (-100, self.BELT_Y); self.belt_pattern_offset = 0
        self.background = self._generate_static_background()
    def _draw_shelf_unit(self, surf, x, y, w, h, rows):
        shadow_offset = 8
        pygame.draw.rect(surf, STATIC_SHADOW_COLOR, (x + shadow_offset, y + shadow_offset, w, h))
        for r in range(rows + 1):
            ry = y + (r * (h / rows))
            pygame.draw.line(surf, (80,80,85), (x, ry), (x + w, ry), 2)
            pygame.draw.line(surf, (120,120,125), (x, ry-1), (x + w, ry-1), 1)
        pygame.draw.line(surf, (80,80,85), (x, y), (x, y + h), 2)
        pygame.draw.line(surf, (80,80,85), (x+w, y), (x+w, y + h), 2)
        for _ in range(rows * 3):
            bx = x + random.randint(5, w - 25)
            by = y + (random.randrange(rows) * (h/rows)) + 5
            bw = random.randint(10, 20); bh = random.randint(5, 10)
            pygame.draw.rect(surf, BOX_COLOR_2, (bx, by, bw, bh))
    def _generate_static_background(self):
        bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        bg.fill(FLOOR_COLOR)
        for _ in range(15000):
            color = random.choice([CONCRETE_NOISE_1, CONCRETE_NOISE_2])
            bg.set_at((random.randint(0, SCREEN_WIDTH-1), random.randint(100, SCREEN_HEIGHT-1)), color)
        for _ in range(20):
            points = []
            px, py = random.randint(0, self.SIMULATION_WIDTH-1), random.randint(200, SCREEN_HEIGHT-1)
            for _ in range(random.randint(3, 6)):
                points.append((px, py))
                px += random.randint(-20, 20); py += random.randint(-20, 20)
            if len(points) > 1: pygame.draw.lines(bg, (100,103,107), False, points, 1)
        wall_rect = pygame.Rect(0, 0, SCREEN_WIDTH, self.BELT_Y - 80)
        bg.fill(WALL_BASE_COLOR, wall_rect)
        for y in range(0, wall_rect.height, 15):
            pygame.draw.line(bg, WALL_LINE_COLOR, (0, y), (SCREEN_WIDTH, y), 1)
        pygame.draw.line(bg, (0,0,0, 100), (0, wall_rect.bottom), (SCREEN_WIDTH, wall_rect.bottom), 2)
        self._draw_shelf_unit(bg, 50, 250, 200, 250, 5)
        self._draw_shelf_unit(bg, 500, 250, 200, 250, 5)
        pygame.draw.rect(bg, (40, 45, 50), (0, 0, SCREEN_WIDTH, 80))
        light_layer = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        light_positions = []
        for i in range(0, SCREEN_WIDTH, 100):
            light_positions.append((i + 40, 38))
            pygame.draw.rect(bg, (30,35,40), (i, 30, 80, 15))
            pygame.draw.rect(bg, (220,220,200), (i+5, 32, 70, 11))
        for lx, ly in light_positions:
            points = [(lx - 20, ly), (lx + 20, ly), (lx + 80, SCREEN_HEIGHT), (lx - 80, SCREEN_HEIGHT)]
            pygame.draw.polygon(light_layer, LIGHT_RAY_COLOR, points)
        bg.blit(light_layer, (0, 0))
        return bg
    def _calculate_layout_parameters(self):
        if not self.visual_list: return {'start_x': self.SIMULATION_WIDTH / 2, 'gap': 0}
        total_box_width = sum(sprite.width for sprite in self.visual_list)
        total_gap_space = self.SIMULATION_WIDTH - total_box_width
        gap_size = total_gap_space / (len(self.visual_list) + 1)
        start_x = gap_size
        return {'start_x': start_x, 'gap': gap_size}
    def _calculate_target_positions(self):
        layout = self._calculate_layout_parameters()
        positions = []; current_x = layout['start_x']
        for sprite in self.visual_list:
            target_x = current_x + sprite.width / 2
            positions.append(target_x)
            current_x += sprite.width + layout['gap']
        return positions
    def draw_environment(self):
        self.screen.blit(self.background, (0, 0))
        belt_height = 40; belt_rect = pygame.Rect(0, self.BELT_Y - belt_height//2, self.SIMULATION_WIDTH, belt_height)
        pygame.draw.rect(self.screen, (20,20,20), belt_rect)
        self.belt_pattern_offset = (self.belt_pattern_offset + 3) % 20
        for x in range(self.belt_pattern_offset, self.SIMULATION_WIDTH, 20):
            pygame.draw.circle(self.screen, (30,30,35), (x, self.BELT_Y), 15)
            pygame.draw.circle(self.screen, (60,60,65), (x, self.BELT_Y), 12)
        hopper_shadow_poly = [(self.HOPPER_X - 80, self.BELT_Y - 120), (self.HOPPER_X + 80, self.BELT_Y - 120), (self.HOPPER_X, self.BELT_Y - 60)]
        pygame.draw.polygon(self.screen, STATIC_SHADOW_COLOR, [(p[0]+8, p[1]+8) for p in hopper_shadow_poly])
        pygame.draw.polygon(self.screen, (120,125,130), [(self.HOPPER_X - 40, 0), (self.HOPPER_X + 40, 0), (self.HOPPER_X + 80, self.BELT_Y - 120), (self.HOPPER_X - 80, self.BELT_Y - 120)])
        pygame.draw.polygon(self.screen, (100,105,110), hopper_shadow_poly)
    def draw_placement_markers(self):
        if not self.placement_mode: return
        self.placement_markers.clear(); mouse_pos = pygame.mouse.get_pos()
        layout = self._calculate_layout_parameters()
        x_coords = [layout['start_x'] / 2]
        current_x = layout['start_x']
        for sprite in self.visual_list:
            current_x += sprite.width; x_coords.append(current_x + layout['gap'] / 2); current_x += layout['gap']
        for i, pos_x in enumerate(x_coords):
            marker_rect = pygame.Rect(pos_x - 20, self.BELT_Y - 35, 40, 70)
            self.placement_markers.append((marker_rect, i))
            color = STRIPE_YELLOW
            if marker_rect.collidepoint(mouse_pos): color = BTN_GREEN_LIGHT
            pygame.draw.rect(self.screen, color, marker_rect, 3, border_radius=6)
    def on_animation_complete(self):
        self.animation_lock_count -= 1
        if self.animation_lock_count <= 0: self.is_animating = False; self.lcd.update_status("READY")
    def animate_to_positions(self):
        self.is_animating = True
        target_positions = self._calculate_target_positions()
        if not self.visual_list: self.is_animating = False; self.lcd.update_status("READY"); return
        self.animation_lock_count = len(self.visual_list)
        for i, sprite in enumerate(self.visual_list): sprite.move_to((target_positions[i], self.BELT_Y), self.on_animation_complete)
    def execute_insertion(self, label, index):
        receipt = self.logic.insert_at(index, label)
        if receipt['type'] == 'ERROR': self.lcd.update_status(f"ERR: {receipt['message']}"); return
        self.lcd.update_status(f"INSERT {label}@{index}"); self.lcd.text = ""
        self.is_animating = True
        size_type = random.choice(list(BOX_SIZES.keys()))
        new_box = BoxSprite(self.HOPPER_X, self.HOPPER_Y, label, size_type)
        self.all_sprites.add(new_box); self.crates_group.add(new_box)
        self.visual_list.insert(index, new_box)
        def stage2_slide_into_place(): self.animate_to_positions()
        new_box.drop_to(self.BELT_Y, callback=stage2_slide_into_place)
    def action_append(self):
        if self.is_animating or self.placement_mode: return
        # --- VALIDATION ---
        text = self.lcd.text
        try:
            val = int(text)
        except ValueError:
            self.lcd.update_status("ERR: INTEGERS ONLY")
            return
        if val < -999 or val > 999:
            self.lcd.update_status("ERR: -999 TO 999")
            return
        label = str(val)
        if self.logic.find_box(label): self.lcd.update_status("ERR: DUPLICATE"); return
        self.execute_insertion(label, len(self.visual_list))
    def action_insert_at(self):
        if self.is_animating: return
        if self.placement_mode: self.placement_mode = False; self.lcd.update_status("CANCELED"); return
        text = self.lcd.text
        try:
            val = int(text)
        except ValueError:
            self.lcd.update_status("ERR: INTEGERS ONLY")
            return
        if val < -999 or val > 999:
            self.lcd.update_status("ERR: -999 TO 999")
            return
        label = str(val)
        if self.logic.find_box(label): self.lcd.update_status("ERR: DUPLICATE"); return
        if self.logic.is_full(): self.lcd.update_status("ERR: CONVEYOR FULL"); return
        self.placement_mode = True; self.label_to_place = label; self.lcd.update_status("CLICK A SLOT...")
    def action_remove(self):
        if self.is_animating or self.placement_mode: return
        label = self.lcd.text.upper()
        if not label: self.lcd.update_status("ERR: NO INPUT"); return
        receipt = self.logic.remove_box(label)[0]
        if receipt['type'] == 'ERROR': self.lcd.update_status(f"ERR: {receipt['message']}"); return
        self.lcd.update_status(f"OUT: {label}"); self.lcd.text = ""
        sprite_to_remove = next((s for s in self.visual_list if s.plate == label), None)
        if sprite_to_remove:
            self.is_animating = True; self.visual_list.remove(sprite_to_remove)
            self.animation_lock_count = 1
            sprite_to_remove.move_to(self.DESPAWN_POINT, callback=lambda: [sprite_to_remove.kill(), self.on_animation_complete()])
            self.animate_to_positions()
    def handle_mouse_click_for_insertion(self, event):
        if self.placement_mode and event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for marker_rect, index in self.placement_markers:
                if marker_rect.collidepoint(event.pos):
                    self.placement_mode = False; self.execute_insertion(self.label_to_place, index); return True
            self.placement_mode = False; self.lcd.update_status("CANCELED"); return True
        return False
    def handle_events(self, event):
        if self.handle_mouse_click_for_insertion(event): return
        if self.placement_mode: return
        self.lcd.handle_event(event); self.btn_append.handle_event(event)
        self.btn_insert.handle_event(event); self.btn_remove.handle_event(event)
    def update(self):
        self.all_sprites.update(); self.lcd.update()
    def draw(self):
        self.draw_environment(); self.all_sprites.draw(self.screen)
        self.draw_placement_markers(); self.chassis.draw(self.screen)
        self.lcd.draw(self.screen); self.btn_append.draw(self.screen)
        self.btn_insert.draw(self.screen); self.btn_remove.draw(self.screen)
</file>

<file path="Full_Stack_Sim/simulation/site_expression_tree.py/site_expression_tree.py">
import pygame
import math
import random
from settings import *
from core.ui import HandheldChassis, LCDDisplay, RoundButton, Button
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.x = 0; self.y = 0
        self.target_x = 0; self.target_y = 0
class ExpressionTreeManager:
    def __init__(self):
        self.root = None
        self.current_depth = 0
        self.precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    def _is_operator(self, char):
        return char in "+-*/^"
    def _infix_to_postfix(self, expression):
        stack = []; output = []
        for char in expression:
            if char.isalnum():
                output.append(char)
            elif char == '(':
                stack.append(char)
            elif char == ')':
                while stack and stack[-1] != '(':
                    output.append(stack.pop())
                if stack and stack[-1] == '(':
                    stack.pop()
            elif self._is_operator(char):
                while (stack and self._is_operator(stack[-1])):
                    p_stack = self.precedence.get(stack[-1], 0)
                    p_char = self.precedence.get(char, 0)
                    is_right_assoc = char == '^'
                    if (p_stack > p_char) or (p_stack == p_char and not is_right_assoc):
                        output.append(stack.pop())
                    else:
                        break
                stack.append(char)
        while stack:
            output.append(stack.pop())
        return output
    def build_from_expression(self, expression):
        expression = "".join(filter(lambda x: not x.isspace(), expression))
        if not expression: return False
        try:
            postfix = self._infix_to_postfix(expression)
            stack = []
            for char in postfix:
                if char.isalnum():
                    stack.append(Node(char))
                elif self._is_operator(char):
                    if len(stack) < 2: return False
                    node = Node(char)
                    node.right = stack.pop()
                    node.left = stack.pop()
                    stack.append(node)
            if len(stack) != 1: return False
            self.root = stack[0]
            self.current_depth = 0
            self._calculate_depth(self.root, 0)
            return True
        except (IndexError, Exception):
            return False
    def _get_label_from_index(self, n):
        label = ""
        if n < 0: return ""
        while True:
            label = chr(n % 26 + ord('A')) + label
            n = n // 26 - 1
            if n < 0:
                break
        return label
    def build_from_levels(self, num_levels):
        """Generates a perfect binary tree of a given depth."""
        if not 1 <= num_levels <= 5: return False
        node_index = 0
        self.root = Node(self._get_label_from_index(node_index))
        node_index += 1
        queue = [self.root]
        for level in range(num_levels - 1):
            for _ in range(len(queue)):
                current = queue.pop(0)
                current.left = Node(self._get_label_from_index(node_index))
                node_index += 1
                queue.append(current.left)
                current.right = Node(self._get_label_from_index(node_index))
                node_index += 1
                queue.append(current.right)
        self.current_depth = num_levels - 1
        return True
    def _calculate_depth(self, node, depth):
        if node is None: return
        self.current_depth = max(self.current_depth, depth)
        self._calculate_depth(node.left, depth + 1)
        self._calculate_depth(node.right, depth + 1)
    def get_traversals(self):
        return {
            "TLR": self._get_pre_order(self.root),
            "LTR": self._get_in_order(self.root),
            "LRT": self._get_post_order(self.root)
        }
    def _get_pre_order(self, node):
        if not node: return []
        return [node] + self._get_pre_order(node.left) + self._get_pre_order(node.right)
    def _get_in_order(self, node):
        if not node: return []
        return self._get_in_order(node.left) + [node] + self._get_in_order(node.right)
    def _get_post_order(self, node):
        if not node: return []
        return self._get_post_order(node.left) + self._get_post_order(node.right) + [node]
class DroneSprite(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.pos_x = float(x); self.pos_y = float(y)
        self.target_x = float(x); self.target_y = float(y)
        self.is_moving = False; self.on_finish_callback = None
        self.rotor_angle = 0
        self.current_size = 0
        self.original_image = None
        self.rotor_image = None
        self.image = pygame.Surface((1,1))
        self.rect = self.image.get_rect(center=(x,y))
        self.resize(40)
    def resize(self, size):
        s = int(size)
        if s < 15: s = 15
        if self.current_size == s: return
        self.current_size = s
        self.original_image = pygame.Surface((s, s), pygame.SRCALPHA)
        center = s // 2
        chassis_radius = s * 0.25
        arm_length = s * 0.5
        rotor_radius = s * 0.12
        arm_color = (80, 85, 90)
        pygame.draw.line(self.original_image, arm_color, (center, center), (center - arm_length, center - arm_length), 3)
        pygame.draw.line(self.original_image, arm_color, (center, center), (center + arm_length, center - arm_length), 3)
        pygame.draw.line(self.original_image, arm_color, (center, center), (center - arm_length, center + arm_length), 3)
        pygame.draw.line(self.original_image, arm_color, (center, center), (center + arm_length, center + arm_length), 3)
        pod_color = (50, 55, 60)
        pygame.draw.circle(self.original_image, pod_color, (center - arm_length, center - arm_length), rotor_radius)
        pygame.draw.circle(self.original_image, pod_color, (center + arm_length, center - arm_length), rotor_radius)
        pygame.draw.circle(self.original_image, pod_color, (center - arm_length, center + arm_length), rotor_radius)
        pygame.draw.circle(self.original_image, pod_color, (center + arm_length, center + arm_length), rotor_radius)
        pygame.draw.circle(self.original_image, (0,0,0,80), (center+2, center+2), chassis_radius)
        pygame.draw.circle(self.original_image, (180,185,190), (center, center), chassis_radius)
        pygame.draw.circle(self.original_image, (100,105,110), (center, center), chassis_radius, 1)
        pygame.draw.circle(self.original_image, (255, 80, 80), (center, center), chassis_radius * 0.5)
        pygame.draw.circle(self.original_image, (255, 150, 150), (center-1, center-1), chassis_radius * 0.2)
        self.rotor_image = pygame.Surface((s,s), pygame.SRCALPHA)
        blade_color = (50,55,60,180)
        blade_length = rotor_radius * 1.5
        for angle in [45, 135, 225, 315]:
            rad = math.radians(angle)
            end_x = center + math.cos(rad) * arm_length
            end_y = center + math.sin(rad) * arm_length
            pygame.draw.line(self.rotor_image, blade_color, (end_x - blade_length, end_y), (end_x + blade_length, end_y), 2)
    def move_to(self, target_pos, callback=None):
        self.target_x, self.target_y = target_pos
        self.on_finish_callback = callback
        self.is_moving = True
    def update(self):
        self.rotor_angle = (self.rotor_angle + 45) % 360
        if self.is_moving:
            dx = self.target_x - self.pos_x; dy = self.target_y - self.pos_y
            dist = math.sqrt(dx**2 + dy**2)
            if dist < 3.0:
                self.pos_x, self.pos_y = self.target_x, self.target_y
                self.is_moving = False
                if self.on_finish_callback:
                    cb = self.on_finish_callback; self.on_finish_callback = None; cb()
            else:
                self.pos_x += dx * 0.15; self.pos_y += dy * 0.15
        self.image = self.original_image.copy()
        rotated_rotors = pygame.transform.rotate(self.rotor_image, self.rotor_angle)
        rotor_rect = rotated_rotors.get_rect(center=self.image.get_rect().center)
        self.image.blit(rotated_rotors, rotor_rect)
        self.rect = self.image.get_rect(center=(int(self.pos_x), int(self.pos_y)))
class ExpressionTreeSimulation:
    def __init__(self, screen):
        self.screen = screen
        self.logic = ExpressionTreeManager()
        self.all_sprites = pygame.sprite.Group()
        self.ui_x = 750; self.ui_w = 250
        self.chassis = HandheldChassis(self.ui_x + 10, 20, self.ui_w - 20, SCREEN_HEIGHT - 40)
        self.lcd = LCDDisplay(self.ui_x + 35, 80, self.ui_w - 70, 100)
        self.lcd.update_status("EXPRESSION PARSER")
        btn_cx = self.ui_x + self.ui_w // 2
        gen_y = 280; btn_radius = 40; h_gap = 15
        self.btn_gen_levels = RoundButton(btn_cx - btn_radius - h_gap, gen_y, btn_radius, BTN_GREEN_BASE, BTN_GREEN_LIGHT, "LEVELS", self.action_gen_levels)
        self.btn_gen_expr = RoundButton(btn_cx + btn_radius + h_gap, gen_y, btn_radius, BTN_ALT_GREEN_BASE, BTN_ALT_GREEN_LIGHT, "EXPR", self.action_gen_expr)
        self.btn_analyze = RoundButton(btn_cx, 390, 40, BTN_BLUE_BASE, BTN_BLUE_LIGHT, "TRAVERSE", self.action_open_analysis_menu)
        self.btn_clear = RoundButton(btn_cx, 490, 40, BTN_RED_BASE, BTN_RED_LIGHT, "CLEAR", self.action_clear)
        self.SIM_WIDTH = 750; self.TOP_MARGIN = 120; self.BOTTOM_MARGIN = 50
        self.ROOT_X = self.SIM_WIDTH // 2; self.current_node_size = 80; self.belt_offset = 0
        self.show_analysis_menu = False; self.manifest_data = None; self.pending_report_data = None
        menu_btn_w, menu_btn_h = 200, 40; menu_cx = self.SIM_WIDTH // 2; menu_start_y = 250
        self.menu_btn_tlr = Button(menu_cx - menu_btn_w//2, menu_start_y, menu_btn_w, menu_btn_h, "TLR (Pre-Order)", lambda: self.action_traverse("TLR"))
        self.menu_btn_ltr = Button(menu_cx - menu_btn_w//2, menu_start_y + 50, menu_btn_w, menu_btn_h, "LTR (In-Order)", lambda: self.action_traverse("LTR"))
        self.menu_btn_lrt = Button(menu_cx - menu_btn_w//2, menu_start_y + 100, menu_btn_w, menu_btn_h, "LRT (Post-Order)", lambda: self.action_traverse("LRT"))
        self.is_traversing = False; self.traversal_path = []; self.traversal_index = 0
        self.highlighted_node = None; self.highlight_timer = 0
        self.drone = DroneSprite(-50, -50); self.all_sprites.add(self.drone)
        self.bg_surface = self._generate_background()
    def _generate_background(self):
        bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        floor_y = SCREEN_HEIGHT
        for y in range(floor_y):
            ratio = y / floor_y
            c = (int(15 + 10*ratio), int(20 + 15*ratio), int(25 + 20*ratio))
            pygame.draw.line(bg, c, (0, y), (SCREEN_WIDTH, y))
        for i in range(0, SCREEN_WIDTH, 120):
            rack_w = 80
            rack_h = 400
            rack_x = i + 20
            rack_y = 100
            pygame.draw.rect(bg, (10, 10, 12), (rack_x, rack_y, rack_w, rack_h))
            pygame.draw.rect(bg, (40, 40, 45), (rack_x, rack_y, rack_w, rack_h), 2)
            for ry in range(rack_y + 10, rack_y + rack_h, 15):
                if random.random() > 0.3:
                    color = random.choice([(0, 255, 0), (255, 0, 0), (0, 100, 255)])
                    pygame.draw.rect(bg, color, (rack_x + 10, ry, 4, 4))
                if random.random() > 0.3:
                    color = random.choice([(0, 255, 0), (255, 0, 0), (0, 100, 255)])
                    pygame.draw.rect(bg, color, (rack_x + 20, ry, 4, 4))
                pygame.draw.line(bg, (30, 30, 35), (rack_x, ry+10), (rack_x+rack_w, ry+10), 1)
        truss_y = 60
        pygame.draw.rect(bg, (20, 20, 20), (0, truss_y, SCREEN_WIDTH, 20))
        for x in range(0, SCREEN_WIDTH, 30):
            pygame.draw.line(bg, (50, 50, 50), (x, truss_y), (x, truss_y+20), 2)
            if random.random() > 0.8:
                h = random.randint(20, 50)
                pygame.draw.line(bg, (10, 10, 10), (x+15, truss_y+20), (x+15, truss_y+20+h), 2)
        floor_start = SCREEN_HEIGHT - 100
        floor_rect = pygame.Rect(0, floor_start, SCREEN_WIDTH, 100)
        bg.fill((40, 45, 50), floor_rect)
        for x in range(0, SCREEN_WIDTH, 50):
            pygame.draw.line(bg, (30, 35, 40), (x, floor_start), (x, SCREEN_HEIGHT), 1)
        for y in range(floor_start, SCREEN_HEIGHT, 30):
            pygame.draw.line(bg, (30, 35, 40), (0, y), (SCREEN_WIDTH, y), 1)
        light_layer = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        light_layer.fill((0, 0, 0, 40))
        for i in range(100, self.SIM_WIDTH, 200):
            lx, ly = i, truss_y + 20
            cone_color = (180, 220, 255)
            points = [
                (lx - 10, ly), (lx + 10, ly),
                (lx + 100, floor_start + 20), (lx - 100, floor_start + 20)
            ]
            pygame.draw.polygon(light_layer, (*cone_color, 15), points)
            pygame.draw.rect(bg, (200, 200, 255), (lx - 20, ly - 5, 40, 5))
        bg.blit(light_layer, (0,0))
        return bg
    def _draw_shelf_unit(self, surf, x, y, w, h, rows, cols):
        pass
    def _draw_pillar(self, surf, x, y, w, h):
        pass
    def _recalculate_layout(self, node, x, y, level, width_spread):
        if node is None: return
        node.target_x = x; node.target_y = y
        depth = self.logic.current_depth
        level_height = (SCREEN_HEIGHT - self.TOP_MARGIN - self.BOTTOM_MARGIN) / max(1, depth) if depth > 0 else 0
        next_spread = width_spread / 2
        self._recalculate_layout(node.left, x - next_spread, y + level_height, level + 1, next_spread)
        self._recalculate_layout(node.right, x + next_spread, y + level_height, level + 1, next_spread)
    def _update_node_positions(self, node):
        if node is None: return
        dx = node.target_x - node.x; dy = node.target_y - node.y
        if abs(dx) > 0.1 or abs(dy) > 0.1:
            node.x += dx * 0.1; node.y += dy * 0.1
        else:
            node.x, node.y = node.target_x, node.target_y
        self._update_node_positions(node.left); self._update_node_positions(node.right)
    def draw_conveyor_line(self, start, end):
        dist = math.hypot(end[0]-start[0], end[1]-start[1])
        if dist == 0: return
        angle = math.atan2(end[1]-start[1], end[0]-start[0]); perp_angle = angle + math.pi / 2
        w = self.current_node_size * 0.4
        dx, dy = math.cos(perp_angle) * w/2, math.sin(perp_angle) * w/2
        points = [(start[0] - dx, start[1] - dy), (start[0] + dx, start[1] + dy),
                  (end[0] + dx, end[1] + dy), (end[0] - dx, end[1] - dy)]
        pygame.draw.polygon(self.screen, (40,40,45), points)
        num_stripes = int(dist / 20)
        if num_stripes > 0:
            for i in range(num_stripes + 2):
                t = (i - self.belt_offset / 20) / num_stripes
                if 0 <= t <= 1:
                    px1 = start[0] + (end[0]-start[0]) * t; py1 = start[1] + (end[1]-start[1]) * t
                    pygame.draw.line(self.screen, (60,60,65), (px1 - dx, py1 - dy), (px1 + dx, py1 + dy), 2)
        pygame.draw.line(self.screen, (90,95,100), points[0], points[3], 5)
        pygame.draw.line(self.screen, (90,95,100), points[1], points[2], 5)
    def draw_tree(self, node):
        if node is None: return
        if node.left:
            self.draw_conveyor_line((node.x, node.y), (node.left.x, node.left.y)); self.draw_tree(node.left)
        if node.right:
            self.draw_conveyor_line((node.x, node.y), (node.right.x, node.right.y)); self.draw_tree(node.right)
        s = int(self.current_node_size); rect = pygame.Rect(0, 0, s, s); rect.center = (node.x, node.y)
        pygame.draw.rect(self.screen, (30,30,35), rect.move(3,3), border_radius=5)
        pygame.draw.rect(self.screen, (80,85,90), rect, border_radius=5)
        is_op = not node.value.isalnum()
        screen_color = (255, 200, 0) if is_op else (150,155,160)
        pygame.draw.rect(self.screen, screen_color, rect.inflate(-10, -10), border_radius=3)
        if self.highlighted_node == node and self.highlight_timer > 0:
            pygame.draw.rect(self.screen, (50, 255, 200), rect, 3, border_radius=5)
        font_size = max(14, int(s * 0.5)); font = pygame.font.SysFont("Impact", font_size)
        txt = font.render(str(node.value), True, (20, 20, 20))
        self.screen.blit(txt, (rect.centerx - txt.get_width()//2, rect.centery - txt.get_height()//2))
    def action_gen_levels(self):
        text = self.lcd.text
        if not text.isdigit() or not (1 <= int(text) <= 5):
            self.lcd.update_status("ERR: LVL 1-5 ONLY"); return
        if self.logic.build_from_levels(int(text)):
            self.manifest_data = None; self.lcd.update_status("TREE GENERATED"); self.lcd.text = ""
    def action_gen_expr(self):
        text = self.lcd.text.upper()
        if not text: self.lcd.update_status("ERR: NO INPUT"); return
        if self.logic.build_from_expression(text):
            self.manifest_data = None; self.lcd.update_status("EXPR PARSED"); self.lcd.text = ""
        else:
            self.lcd.update_status("ERR: INVALID EXPR")
    def action_clear(self):
        self.logic.root = None; self.manifest_data = None
        self.lcd.update_status("SYSTEM CLEARED"); self.lcd.text = ""
    def action_open_analysis_menu(self):
        if self.is_traversing or not self.logic.root: return
        self.show_analysis_menu = True
    def action_traverse(self, order_type):
        self.show_analysis_menu = False
        all_traversals = self.logic.get_traversals()
        self.traversal_path = all_traversals[order_type]
        self.pending_report_data = {
            "title": f"{order_type} (Post-Order)" if order_type == "LRT" else f"{order_type} (Pre-Order)" if order_type == "TLR" else f"{order_type} (In-Order)",
            "path": " ".join([node.value for node in self.traversal_path])
        }
        self.is_traversing = True; self.traversal_index = 0
        self.drone.pos_x, self.drone.pos_y = self.ROOT_X, 20
        self.lcd.update_status("ANALYZING..."); self.process_next_traversal_step()
    def process_next_traversal_step(self):
        if self.traversal_index >= len(self.traversal_path):
            self.on_traversal_complete(); return
        node_to_visit = self.traversal_path[self.traversal_index]
        self.drone.move_to((node_to_visit.x, node_to_visit.y), callback=self.on_drone_arrival)
    def on_drone_arrival(self):
        node = self.traversal_path[self.traversal_index]
        self.highlighted_node = node; self.highlight_timer = 20
        self.traversal_index += 1; self.process_next_traversal_step()
    def on_traversal_complete(self):
        self.is_traversing = False; self.traversal_path = []; self.traversal_index = 0
        self.drone.move_to((-50, -50)); self.lcd.update_status("ANALYSIS DONE")
        self.manifest_data = self.pending_report_data; self.pending_report_data = None
    def handle_events(self, event):
        if self.show_analysis_menu:
            self.menu_btn_tlr.handle_event(event); self.menu_btn_ltr.handle_event(event); self.menu_btn_lrt.handle_event(event)
            if event.type == pygame.MOUSEBUTTONDOWN and not (self.menu_btn_tlr.is_hovered or self.menu_btn_ltr.is_hovered or self.menu_btn_lrt.is_hovered):
                self.show_analysis_menu = False
            return
        if self.manifest_data and not self.is_traversing:
            if event.type == pygame.MOUSEBUTTONDOWN:
                self.manifest_data = None; self.lcd.update_status("READY")
            return
        self.lcd.handle_event(event); self.btn_gen_levels.handle_event(event)
        self.btn_gen_expr.handle_event(event); self.btn_analyze.handle_event(event); self.btn_clear.handle_event(event)
    def update(self):
        if self.show_analysis_menu: return
        self.belt_offset = (self.belt_offset + 2) % 20
        if self.highlight_timer > 0:
            self.highlight_timer -= 1
            if self.highlight_timer == 0: self.highlighted_node = None
        if self.logic.root:
            depth = self.logic.current_depth
            slot_width = self.SIM_WIDTH / max(1, 2 ** depth)
            target_node_size = int(slot_width * 0.50)
            if target_node_size > 80: target_node_size = 80
            if target_node_size < 30: target_node_size = 30
            size_diff = target_node_size - self.current_node_size
            if abs(size_diff) > 0.1: self.current_node_size += size_diff * 0.1
            else: self.current_node_size = target_node_size
            self._recalculate_layout(self.logic.root, self.ROOT_X, self.TOP_MARGIN, 0, self.SIM_WIDTH / 2)
            self._update_node_positions(self.logic.root)
            self.drone.resize(self.current_node_size * 0.8)
        self.all_sprites.update(); self.lcd.update()
    def draw_analysis_menu(self):
        overlay = pygame.Surface((self.SIM_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        font_title = pygame.font.SysFont("Impact", 30)
        title_surf = font_title.render("SELECT ANALYSIS METHOD", True, WHITE)
        self.screen.blit(title_surf, (self.SIM_WIDTH//2 - title_surf.get_width()//2, 180))
        self.menu_btn_tlr.draw(self.screen); self.menu_btn_ltr.draw(self.screen); self.menu_btn_lrt.draw(self.screen)
    def draw_manifest(self):
        overlay = pygame.Surface((self.SIM_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        w, h = 500, 220; x, y = (self.SIM_WIDTH - w) // 2, (SCREEN_HEIGHT - h) // 2
        pygame.draw.rect(self.screen, (0,0,0,80), (x+5, y+5, w, h), border_radius=3)
        pygame.draw.rect(self.screen, (230, 230, 220), (x, y, w, h), border_radius=3)
        pygame.draw.rect(self.screen, (100,100,100), (x,y,w,h), 1, border_radius=3)
        font_header = pygame.font.SysFont("Courier New", 18, bold=True)
        header_surf = font_header.render("ANALYSIS MANIFEST", True, (30,30,30))
        self.screen.blit(header_surf, (x + w//2 - header_surf.get_width()//2, y + 20))
        pygame.draw.line(self.screen, (180,180,170), (x+20, y+50), (x+w-20, y+50), 1)
        font_label = pygame.font.SysFont("Courier New", 16, bold=True)
        font_result = pygame.font.SysFont("Courier New", 20)
        label_surf = font_label.render(self.manifest_data['title'] + ":", True, (80,80,80))
        self.screen.blit(label_surf, (x+20, y + 70))
        words = self.manifest_data["path"].split(' ')
        lines = []; current_line = ""
        for word in words:
            test_line = current_line + word + " "
            if font_result.size(test_line)[0] < w - 40:
                current_line = test_line
            else:
                lines.append(current_line); current_line = word + " "
        lines.append(current_line)
        line_y = y + 100
        for line in lines:
            result_surf = font_result.render(line, True, (40, 40, 40))
            self.screen.blit(result_surf, (x + 25, line_y)); line_y += 25
        font_prompt = pygame.font.SysFont("Arial", 12)
        prompt_surf = font_prompt.render("Click anywhere to dismiss", True, (150, 150, 150))
        self.screen.blit(prompt_surf, (x + w - prompt_surf.get_width() - 10, y + h - prompt_surf.get_height() - 10))
    def draw(self):
        self.screen.blit(self.bg_surface, (0, 0))
        self.draw_tree(self.logic.root)
        self.all_sprites.draw(self.screen)
        self.chassis.draw(self.screen); self.lcd.draw(self.screen)
        self.btn_gen_levels.draw(self.screen); self.btn_gen_expr.draw(self.screen)
        self.btn_analyze.draw(self.screen); self.btn_clear.draw(self.screen)
        if self.show_analysis_menu: self.draw_analysis_menu()
        elif self.manifest_data: self.draw_manifest()
</file>

<file path="Full_Stack_Sim/simulation/site_parking_queue.py/site_parking_queue.py">
import pygame
import random
import math
from settings import *
from core.sprites import CrateSprite
from core.ui import HandheldChassis, LCDDisplay, RoundButton
class Vehicle:
    def __init__(self, plate, arrival_count, departure_count):
        self.plate = plate
        self.arrival_count = arrival_count
        self.departure_count = departure_count
class QueueManager:
    def __init__(self, capacity=10):
        self.items = []
        self.capacity = capacity
        self.history = {}
    def _get_stats(self, plate):
        if plate not in self.history:
            self.history[plate] = {'arrivals': 0, 'departures': 0}
        return self.history[plate]
    def enqueue(self, plate):
        if len(self.items) >= self.capacity:
            return {"type": "OVERFLOW", "message": "LANE FULL"}
        for v in self.items:
            if v.plate == plate:
                return {"type": "DUPLICATE", "message": "ALREADY HERE"}
        stats = self._get_stats(plate)
        stats['arrivals'] += 1
        new_vehicle = Vehicle(plate, stats['arrivals'], stats['departures'])
        self.items.append(new_vehicle)
        return {
            "type": "ENQUEUE",
            "index": len(self.items) - 1,
            "data": new_vehicle
        }
    def remove_vehicle(self, plate):
        target_index = -1
        for i, v in enumerate(self.items):
            if v.plate == plate:
                target_index = i
                break
        if target_index == -1:
            return [{"type": "ERROR", "message": "NOT FOUND"}]
        events = []
        for _ in range(target_index):
            cycling_vehicle = self.items.pop(0)
            stats = self._get_stats(cycling_vehicle.plate)
            stats['departures'] += 1
            stats['arrivals'] += 1
            cycling_vehicle.arrival_count = stats['arrivals']
            cycling_vehicle.departure_count = stats['departures']
            self.items.append(cycling_vehicle)
            events.append({
                "type": "CYCLE",
                "data": cycling_vehicle,
                "new_index": len(self.items) - 1
            })
        target_vehicle = self.items.pop(0)
        stats = self._get_stats(target_vehicle.plate)
        stats['departures'] += 1
        events.append({
            "type": "DEPART",
            "data": target_vehicle,
            "stats": stats
        })
        return events
    def get_inventory_report(self):
        report = []
        for v in self.items:
            stats = self.history[v.plate]
            report.append({
                "plate": v.plate,
                "arrivals": stats['arrivals'],
                "departures": stats['departures']
            })
        return report
class ParkingQueueSimulation:
    def __init__(self, screen):
        self.screen = screen
        self.logic = QueueManager(capacity=10)
        self.all_sprites = pygame.sprite.Group()
        self.crates_group = pygame.sprite.Group()
        self.ui_x = 750
        self.ui_y = 0
        self.ui_w = 250
        self.ui_h = SCREEN_HEIGHT
        self.chassis = HandheldChassis(self.ui_x + 10, 20, self.ui_w - 20, SCREEN_HEIGHT - 40)
        self.lcd = LCDDisplay(self.ui_x + 35, 80, self.ui_w - 70, 100)
        self.lcd.update_status("WEIGH STATION")
        btn_cx = self.ui_x + self.ui_w // 2
        self.btn_arrive = RoundButton(btn_cx, 280, 45, BTN_GREEN_BASE, BTN_GREEN_LIGHT, "ENQUEUE", self.action_arrive)
        self.btn_depart = RoundButton(btn_cx, 390, 45, BTN_RED_BASE, BTN_RED_LIGHT, "DEQUEUE", self.action_depart)
        self.btn_summary = RoundButton(btn_cx, 500, 45, BTN_BLUE_BASE, BTN_BLUE_LIGHT, "SUMMARY", self.action_summary)
        self.btn_skip = RoundButton(btn_cx, 590, 30, (100, 100, 100), (150, 150, 150), "SKIP", self.action_skip)
        self.visual_queue = []
        self.is_animating = False
        self.show_summary = False
        self.event_queue = []
        self.LANE_Y = 320
        self.SCALE_FACTOR = 0.7
        self.SLOT_GAP = 72
        self.GATE_X = 700
        self.ENTRY_SPAWN = (-100, self.LANE_Y)
        self.EXIT_POINT = (SCREEN_WIDTH + 100, self.LANE_Y)
        self.LOOP_EXIT_X = self.GATE_X + 40
        self.LOOP_DOWN_Y = 580
        self.LOOP_BACK_X = 20
        self.bg_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        self._generate_static_environment()
    def draw_container(self, surf, x, y, color, angle=0):
        w, h = 120, 50
        c_surf = pygame.Surface((w, h), pygame.SRCALPHA)
        pygame.draw.rect(surf, SHADOW_COLOR, (x+5, y+5, w, h))
        pygame.draw.rect(c_surf, color, (0, 0, w, h))
        pygame.draw.rect(c_surf, (30, 30, 30), (0, 0, w, h), 1)
        for i in range(0, w, 10):
            pygame.draw.line(c_surf, CONTAINER_RIB, (i, 0), (i, h), 2)
        pygame.draw.rect(c_surf, (200, 200, 200), (5, 5, 30, 10))
        if angle != 0:
            c_surf = pygame.transform.rotate(c_surf, angle)
        surf.blit(c_surf, (x, y))
    def draw_barrel_group(self, surf, x, y):
        positions = [(0,0), (15,5), (5, 15)]
        for dx, dy in positions:
            bx, by = x + dx, y + dy
            pygame.draw.circle(surf, SHADOW_COLOR, (bx+2, by+2), 7)
            pygame.draw.circle(surf, BARREL_BLUE, (bx, by), 7)
            pygame.draw.circle(surf, BARREL_RIM, (bx, by), 7, 1)
            pygame.draw.circle(surf, (20, 20, 30), (bx+2, by+2), 2)
    def draw_fence(self, surf, start, end):
        pygame.draw.line(surf, FENCE_SHADOW, (start[0]+2, start[1]+2), (end[0]+2, end[1]+2), 2)
        pygame.draw.line(surf, FENCE_COLOR, start, end, 2)
        dist = math.hypot(end[0]-start[0], end[1]-start[1])
        count = int(dist // 30)
        for i in range(count + 1):
            t = i / count if count > 0 else 0
            px = start[0] + (end[0] - start[0]) * t
            py = start[1] + (end[1] - start[1]) * t
            pygame.draw.circle(surf, (100, 100, 100), (int(px), int(py)), 3)
    def draw_drain(self, surf, x, y):
        pygame.draw.rect(surf, DRAIN_METAL, (x, y, 30, 30))
        pygame.draw.rect(surf, (30, 30, 30), (x, y, 30, 30), 2)
        for i in range(x+5, x+30, 5):
            pygame.draw.line(surf, (30, 30, 30), (i, y), (i, y+30), 2)
    def draw_crack(self, surf, x, y):
        points = [(x, y)]
        curr_x, curr_y = x, y
        for _ in range(4):
            curr_x += random.randint(-10, 10)
            curr_y += random.randint(-10, 10)
            points.append((curr_x, curr_y))
        pygame.draw.lines(surf, CRACK_COLOR, False, points, 1)
    def _generate_static_environment(self):
        surf = self.bg_surface
        surf.fill(YARD_CONCRETE)
        for _ in range(8000):
            x = random.randint(0, 750)
            y = random.randint(0, SCREEN_HEIGHT)
            color = random.choice([YARD_NOISE_1, YARD_NOISE_2])
            surf.set_at((x, y), color)
        for _ in range(20):
            self.draw_crack(surf, random.randint(0, 750), random.randint(0, 700))
        rw = 80
        def draw_road_rect(rect):
            pygame.draw.rect(surf, ASPHALT_BASE, rect)
            for _ in range(int(rect.width * rect.height * 0.005)):
                rx = random.randint(rect.left, rect.right-1)
                ry = random.randint(rect.top, rect.bottom-1)
                surf.set_at((rx, ry), ASPHALT_DARK)
        draw_road_rect(pygame.Rect(-100, self.LANE_Y - rw//2, 900, rw))
        draw_road_rect(pygame.Rect(self.LOOP_EXIT_X - rw//2, self.LANE_Y, rw, self.LOOP_DOWN_Y - self.LANE_Y))
        draw_road_rect(pygame.Rect(self.LOOP_BACK_X, self.LOOP_DOWN_Y - rw//2, self.LOOP_EXIT_X - self.LOOP_BACK_X, rw))
        draw_road_rect(pygame.Rect(self.LOOP_BACK_X - rw//2, self.LANE_Y, rw, self.LOOP_DOWN_Y - self.LANE_Y))
        for x in range(-100, 800, 60):
            pygame.draw.line(surf, ROAD_STRIPE, (x, self.LANE_Y), (x+30, self.LANE_Y), 2)
        pygame.draw.line(surf, (255, 255, 255), (self.GATE_X, self.LANE_Y - 35), (self.GATE_X, self.LANE_Y + 35), 6)
        self.draw_drain(surf, 200, 500)
        self.draw_drain(surf, 600, 500)
        oil_surf = pygame.Surface((60, 40), pygame.SRCALPHA)
        pygame.draw.ellipse(oil_surf, OIL_STAIN, (0,0,60,40))
        surf.blit(oil_surf, (self.GATE_X - 20, self.LANE_Y + 10))
        island_rect = pygame.Rect(self.LOOP_BACK_X + 40 + 10, self.LANE_Y + 40 + 10,
                                  (self.LOOP_EXIT_X - self.LOOP_BACK_X) - 80 - 20,
                                  (self.LOOP_DOWN_Y - self.LANE_Y) - 80 - 20)
        pygame.draw.rect(surf, (125, 125, 130), island_rect)
        for i in range(island_rect.left, island_rect.right, 20):
            p1 = (i, island_rect.bottom)
            p2 = (i + 20, island_rect.top)
            if p2[0] < island_rect.right:
                pygame.draw.line(surf, (115, 115, 120), p1, p2, 2)
        self.draw_container(surf, island_rect.left + 20, island_rect.top + 20, CONTAINER_RED)
        self.draw_container(surf, island_rect.left + 40, island_rect.top + 10, CONTAINER_BLUE)
        self.draw_container(surf, island_rect.left + 160, island_rect.top + 30, CONTAINER_GREEN, angle=10)
        self.draw_barrel_group(surf, island_rect.right - 60, island_rect.bottom - 60)
        self.draw_barrel_group(surf, island_rect.right - 80, island_rect.bottom - 40)
        self._draw_static_pallet(surf, island_rect.right - 120, island_rect.bottom - 50)
        self._draw_static_pallet(surf, island_rect.right - 120, island_rect.bottom - 80)
        self.draw_fence(surf, (0, 180), (400, 180))
        self.draw_fence(surf, (400, 180), (400, 0))
        for i in range(3):
            for j in range(2):
                self._draw_static_pallet(surf, 50 + i*40, 100 + j*40)
        self.draw_container(surf, 100, 620, CONTAINER_BLUE)
        self.draw_container(surf, 230, 630, CONTAINER_RED, angle=-5)
    def _draw_static_pallet(self, surf, x, y):
        pygame.draw.rect(surf, SHADOW_COLOR, (x+5, y+5, 30, 30))
        pygame.draw.rect(surf, BOX_COLOR_2, (x, y, 30, 30))
        pygame.draw.line(surf, BOX_TAPE, (x, y+5), (x+30, y+5), 2)
        pygame.draw.line(surf, BOX_TAPE, (x, y+15), (x+30, y+15), 2)
        pygame.draw.line(surf, BOX_TAPE, (x, y+25), (x+30, y+25), 2)
    def draw_brick_building(self, x, y, w, h, label):
        pygame.draw.rect(self.screen, SHADOW_COLOR, (x+10, y+10, w, h))
        rect = pygame.Rect(x, y, w, h)
        pygame.draw.rect(self.screen, BRICK_RED, rect)
        for by in range(y, y+h, 10):
            pygame.draw.line(self.screen, BRICK_DETAIL, (x, by), (x+w, by), 1)
            offset = 0 if (by//10)%2==0 else 10
            for bx in range(x + offset, x+w, 20):
                pygame.draw.line(self.screen, BRICK_DETAIL, (bx, by), (bx, by+10), 1)
        pygame.draw.rect(self.screen, (50, 30, 30), rect, 2)
        roof_h = h - 15
        roof_rect = pygame.Rect(x-4, y-4, w+8, roof_h)
        pygame.draw.rect(self.screen, ROOF_TAR, roof_rect)
        pygame.draw.rect(self.screen, (30, 30, 30), roof_rect, 2)
        font = pygame.font.SysFont("Arial", 10, bold=True)
        txt = font.render(label, True, (200, 200, 200))
        self.screen.blit(txt, (x + w//2 - txt.get_width()//2, y + roof_h//2))
    def draw_bollard(self, x, y):
        pygame.draw.circle(self.screen, SHADOW_COLOR, (x+3, y+3), 6)
        pygame.draw.circle(self.screen, (50, 50, 50), (x, y), 6)
        pygame.draw.circle(self.screen, BOLLARD_YELLOW, (x, y), 4)
    def draw_dynamic_environment(self):
        self.screen.blit(self.bg_surface, (0, 0))
        self.draw_brick_building(self.GATE_X + 20, self.LANE_Y - 130, 80, 60, "GUARD")
        wh_rect = pygame.Rect(450, 30, 250, 120)
        pygame.draw.rect(self.screen, SHADOW_COLOR, wh_rect.move(10, 10))
        pygame.draw.rect(self.screen, WAREHOUSE_WALL, wh_rect)
        for i in range(wh_rect.left, wh_rect.right, 10):
            pygame.draw.line(self.screen, (150, 155, 160), (i, wh_rect.top), (i, wh_rect.bottom), 1)
        pygame.draw.rect(self.screen, (100, 100, 100), wh_rect, 2)
        pygame.draw.rect(self.screen, WAREHOUSE_ROOF, (440, 20, 270, 100))
        pygame.draw.rect(self.screen, (80, 80, 80), (440, 20, 270, 100), 2)
        font = pygame.font.SysFont("Impact", 20)
        lbl = font.render("LOGISTICS HUB", True, (180, 180, 180))
        self.screen.blit(lbl, (575 - lbl.get_width()//2, 60))
        scale_rect = pygame.Rect(self.GATE_X - 80, self.LANE_Y - 35, 100, 70)
        pygame.draw.rect(self.screen, (50, 50, 50), scale_rect)
        pygame.draw.rect(self.screen, (180, 180, 180), scale_rect.inflate(-4, -4))
        pygame.draw.rect(self.screen, (100, 100, 100), scale_rect.inflate(-4, -4), 1)
        gate_pivot = (self.GATE_X + 25, self.LANE_Y - 40)
        pygame.draw.circle(self.screen, (200, 50, 50), gate_pivot, 6)
        pygame.draw.line(self.screen, (255, 255, 255), gate_pivot, (self.GATE_X + 25, self.LANE_Y + 40), 4)
        pygame.draw.line(self.screen, (200, 0, 0), gate_pivot, (self.GATE_X + 25, self.LANE_Y + 40), 4)
        island_rect = pygame.Rect(self.LOOP_BACK_X + 40 + 10, self.LANE_Y + 40 + 10,
                                  (self.LOOP_EXIT_X - self.LOOP_BACK_X) - 80 - 20,
                                  (self.LOOP_DOWN_Y - self.LANE_Y) - 80 - 20)
        self.draw_bollard(island_rect.left, island_rect.top)
        self.draw_bollard(island_rect.right, island_rect.top)
        self.draw_bollard(island_rect.left, island_rect.bottom)
        self.draw_bollard(island_rect.right, island_rect.bottom)
    def _scale_sprite(self, sprite):
        w = int(sprite.original_image.get_width() * self.SCALE_FACTOR)
        h = int(sprite.original_image.get_height() * self.SCALE_FACTOR)
        sprite.original_image = pygame.transform.smoothscale(sprite.original_image, (w, h))
        sprite.image = sprite.original_image.copy()
        sprite.rect = sprite.image.get_rect(center=sprite.rect.center)
    def _force_orientation(self, sprite, angle):
        sprite.angle = angle
        sprite.image = pygame.transform.rotate(sprite.original_image, angle)
        sprite.rect = sprite.image.get_rect(center=(sprite.pos_x, sprite.pos_y))
    def _realign_queue(self, exclude_sprites=None):
        if exclude_sprites is None:
            exclude_sprites = []
        for i, sprite in enumerate(self.visual_queue):
            if sprite in exclude_sprites:
                continue
            target_x = self.GATE_X - (i * self.SLOT_GAP)
            if abs(sprite.pos_x - target_x) > 5:
                sprite.move_to((target_x, self.LANE_Y), callback=lambda s=sprite: self._force_orientation(s, 0))
    def action_arrive(self):
        if self.is_animating or self.show_summary: return
        plate = self.lcd.text.upper()
        if not plate:
            self.lcd.update_status("ERR: NO INPUT")
            return
        if len(plate) > 10:
            self.lcd.update_status("ERR: MAX 10 CHARS")
            return
        receipt = self.logic.enqueue(plate)
        if receipt['type'] in ['OVERFLOW', 'DUPLICATE']:
            self.lcd.update_status(f"ERR: {receipt['message']}")
            return
        self.lcd.update_status(f"IN: {plate}")
        self.lcd.text = ""
        new_crate = CrateSprite(self.ENTRY_SPAWN[0], self.ENTRY_SPAWN[1], receipt['data'].plate)
        self._scale_sprite(new_crate)
        self.all_sprites.add(new_crate)
        self.crates_group.add(new_crate)
        self.visual_queue.append(new_crate)
        target_x = self.GATE_X - (receipt['index'] * self.SLOT_GAP)
        self.is_animating = True
        new_crate.move_to((target_x, self.LANE_Y), callback=self.on_animation_complete)
    def action_depart(self):
        if self.is_animating or self.show_summary: return
        plate = self.lcd.text.upper()
        if not plate: return
        events = self.logic.remove_vehicle(plate)
        if events[0]['type'] == 'ERROR':
            self.lcd.update_status(f"ERR: {events[0]['message']}")
            return
        self.lcd.update_status(f"OUT: {plate}")
        self.lcd.text = ""
        self.is_animating = True
        self.event_queue = events
        self.process_next_event()
    def action_skip(self):
        """Resets the simulation state to match the logic state instantly."""
        if not self.is_animating: return
        # Stop all movement
        for s in self.all_sprites:
            s.is_moving = False
            s.on_finish_callback = None
        self.event_queue = []
        # Sync Visuals to Logic
        valid_plates = [v.plate for v in self.logic.items]
        for sprite in self.crates_group:
            if sprite.plate not in valid_plates:
                sprite.kill()
        self.visual_queue = []
        for vehicle in self.logic.items:
            found_sprite = next((s for s in self.crates_group if s.plate == vehicle.plate), None)
            if found_sprite:
                self.visual_queue.append(found_sprite)
        # Snap sprites to correct positions
        for i, sprite in enumerate(self.visual_queue):
            target_x = self.GATE_X - (i * self.SLOT_GAP)
            sprite.pos_x = target_x
            sprite.pos_y = self.LANE_Y
            sprite.rect.center = (int(sprite.pos_x), int(sprite.pos_y))
            self._force_orientation(sprite, 0)
        self.is_animating = False
        self.lcd.update_status("READY")
    def process_next_event(self):
        if not self.event_queue:
            self._realign_queue()
            self.on_animation_complete()
            return
        event = self.event_queue.pop(0)
        if event['type'] == 'CYCLE':
            sprite = self.visual_queue.pop(0)
            self.visual_queue.append(sprite)
            self._realign_queue(exclude_sprites=[sprite])
            final_slot_x = self.GATE_X - (event['new_index'] * self.SLOT_GAP)
            def step4_to_slot():
                sprite.move_to((final_slot_x, self.LANE_Y), callback=lambda: [self._force_orientation(sprite, 0), self.process_next_event()])
            def step3_up():
                self._force_orientation(sprite, 90)
                sprite.move_to((self.LOOP_BACK_X + 30, self.LANE_Y), callback=step4_to_slot)
            def step2_left():
                self._force_orientation(sprite, 180)
                sprite.move_to((self.LOOP_BACK_X + 30, self.LOOP_DOWN_Y + 30), callback=step3_up)
            def step1_down():
                self._force_orientation(sprite, 270)
                sprite.move_to((self.LOOP_EXIT_X, self.LOOP_DOWN_Y + 30), callback=step2_left)
            sprite.move_to((self.LOOP_EXIT_X, self.LANE_Y), callback=step1_down)
        elif event['type'] == 'DEPART':
            sprite = self.visual_queue.pop(0)
            def cleanup():
                sprite.kill()
                self._realign_queue()
                self.process_next_event()
            sprite.move_to(self.EXIT_POINT, callback=cleanup)
    def action_summary(self):
        self.show_summary = not self.show_summary
    def on_animation_complete(self):
        self.is_animating = False
        self._force_orientation_all()
        self.lcd.update_status("READY")
    def _force_orientation_all(self):
        for s in self.crates_group:
            s.angle = 0
            s.image = pygame.transform.rotate(s.original_image, 0)
            s.rect = s.image.get_rect(center=(s.pos_x, s.pos_y))
    def handle_events(self, event):
        if self.show_summary:
            if event.type == pygame.MOUSEBUTTONDOWN:
                self.show_summary = False
            return
        self.lcd.handle_event(event)
        self.btn_arrive.handle_event(event)
        self.btn_depart.handle_event(event)
        self.btn_summary.handle_event(event)
        self.btn_skip.handle_event(event)
    def update(self):
        if self.show_summary: return
        self.all_sprites.update()
        self.lcd.update()
    def draw_summary_overlay(self):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        overlay.set_alpha(230)
        overlay.fill((20, 25, 30))
        self.screen.blit(overlay, (0, 0))
        font_title = pygame.font.SysFont("Arial", 24, bold=True)
        font_mono = pygame.font.SysFont("Courier New", 14)
        pygame.draw.rect(self.screen, (255, 200, 50), (0, 40, SCREEN_WIDTH, 50))
        title = font_title.render("WEIGH STATION MANIFEST", True, (20, 20, 20))
        self.screen.blit(title, (SCREEN_WIDTH//2 - title.get_width()//2, 55))
        headers = f"{'PLATE ID':<15} {'ARRIVALS':<10} {'DEPARTURES':<10}"
        self.screen.blit(font_mono.render(headers, True, (255, 200, 50)), (SCREEN_WIDTH//2 - 150, 120))
        pygame.draw.line(self.screen, (255, 200, 50), (SCREEN_WIDTH//2 - 160, 135), (SCREEN_WIDTH//2 + 160, 135), 1)
        report = self.logic.get_inventory_report()
        start_y = 150
        for i, item in enumerate(report):
            txt = f"{item['plate']:<15} {item['arrivals']:<10} {item['departures']:<10}"
            col = (255, 255, 255) if i % 2 == 0 else (200, 200, 210)
            self.screen.blit(font_mono.render(txt, True, col), (SCREEN_WIDTH//2 - 150, start_y + i*20))
    def draw(self):
        self.draw_dynamic_environment()
        self.all_sprites.draw(self.screen)
        for sprite in self.crates_group:
            label_x = sprite.rect.centerx - sprite.label_surf.get_width() // 2
            label_y = sprite.rect.centery - 35
            self.screen.blit(sprite.label_surf, (label_x, label_y))
        self.chassis.draw(self.screen)
        self.lcd.draw(self.screen)
        self.btn_arrive.draw(self.screen)
        self.btn_depart.draw(self.screen)
        self.btn_summary.draw(self.screen)
        self.btn_skip.draw(self.screen)
        if self.show_summary:
            self.draw_summary_overlay()
</file>

<file path="Full_Stack_Sim/simulation/site_parking_stack.py/site_parking_stack.py">
import pygame
import random
from settings import *
from core.sprites import CrateSprite
from core.ui import HandheldChassis, LCDDisplay, RoundButton
class Vehicle:
    def __init__(self, plate, arrival_count, departure_count):
        self.plate = plate
        self.arrival_count = arrival_count
        self.departure_count = departure_count
class StackManager:
    def __init__(self, capacity=10):
        self.items = []
        self.capacity = capacity
        self.history = {}
    def _get_stats(self, plate):
        if plate not in self.history: self.history[plate] = {'arrivals': 0, 'departures': 0}
        return self.history[plate]
    def push(self, plate):
        if len(self.items) >= self.capacity: return {"type": "OVERFLOW", "message": "BAY FULL"}
        if any(v.plate == plate for v in self.items): return {"type": "DUPLICATE", "message": "ALREADY HERE"}
        stats = self._get_stats(plate)
        stats['arrivals'] += 1
        new_vehicle = Vehicle(plate, stats['arrivals'], stats['departures'])
        self.items.append(new_vehicle)
        return {"type": "PUSH", "index": len(self.items) - 1, "data": new_vehicle}
    def remove_vehicle(self, plate):
        target_index = -1
        for i, v in enumerate(self.items):
            if v.plate == plate: target_index = i; break
        if target_index == -1: return [{"type": "ERROR", "message": "NOT FOUND"}]
        events = []
        current_top_index = len(self.items) - 1
        temp_holding = []
        while len(self.items) > target_index + 1:
            v = self.items.pop()
            temp_holding.append(v)
            stats = self._get_stats(v.plate)
            stats['departures'] += 1
            events.append({"type": "TEMP_POP", "data": v, "index": current_top_index})
            current_top_index -= 1
        target_vehicle = self.items.pop()
        stats = self._get_stats(target_vehicle.plate)
        stats['departures'] += 1
        events.append({"type": "FINAL_POP", "data": target_vehicle, "index": target_index, "stats": stats})
        for v in reversed(temp_holding):
            self.items.append(v)
            stats = self._get_stats(v.plate)
            stats['arrivals'] += 1
            events.append({"type": "RESTACK_PUSH", "data": v, "index": len(self.items) - 1})
        return events
    def get_inventory_report(self):
        report = []
        for v in self.items:
            stats = self.history[v.plate]
            report.append({"plate": v.plate, "arrivals": stats['arrivals'], "departures": stats['departures']})
        return report
class ParkingStackSimulation:
    def __init__(self, screen):
        self.screen = screen
        self.logic = StackManager(capacity=10)
        self.all_sprites = pygame.sprite.Group()
        self.crates_group = pygame.sprite.Group()
        self.ui_x = 750; self.ui_y = 0; self.ui_w = 250; self.ui_h = SCREEN_HEIGHT
        self.chassis = HandheldChassis(self.ui_x + 10, 20, self.ui_w - 20, SCREEN_HEIGHT - 40)
        self.lcd = LCDDisplay(self.ui_x + 35, 80, self.ui_w - 70, 100)
        self.lcd.update_status("MAINTENANCE BAY")
        btn_cx = self.ui_x + self.ui_w // 2
        self.btn_arrive = RoundButton(btn_cx, 280, 45, BTN_GREEN_BASE, BTN_GREEN_LIGHT, "ARRIVE", self.action_arrive)
        self.btn_depart = RoundButton(btn_cx, 390, 45, BTN_RED_BASE, BTN_RED_LIGHT, "DEPART", self.action_depart)
        self.btn_summary = RoundButton(btn_cx, 500, 45, BTN_BLUE_BASE, BTN_BLUE_LIGHT, "SUMMARY", self.action_summary)
        self.btn_skip = RoundButton(btn_cx, 590, 30, (100, 100, 100), (150, 150, 150), "SKIP", self.action_skip)
        self.visual_stack = []
        self.holding_stack_height = 0
        self.last_receipt = None
        self.event_queue = []
        self.is_animating = False
        self.show_summary = False
    def draw_pallet(self, x, y, boxes=2):
        pygame.draw.rect(self.screen, (100, 80, 50), (x, y, 30, 20))
        pygame.draw.line(self.screen, (60, 40, 20), (x, y+10), (x+30, y+10), 2)
        for i in range(boxes):
            bx = x + 2 + (i*10); by = y - 10
            pygame.draw.rect(self.screen, BOX_COLOR_1, (bx, by, 12, 12))
            pygame.draw.rect(self.screen, (80, 60, 40), (bx, by, 12, 12), 1)
    def draw_vent(self, x, y):
        pygame.draw.rect(self.screen, (40, 40, 45), (x, y, 20, 20))
        for i in range(0, 20, 4):
            pygame.draw.line(self.screen, (30, 30, 35), (x, y+i), (x+20, y+i), 1)
    def draw_environment(self):
        self.screen.fill(ASPHALT_STACK_BASE)
        for _ in range(5000):
            color = ASPHALT_STACK_NOISE
            self.screen.set_at((random.randint(0, 749), random.randint(0, SCREEN_HEIGHT-1)), color)
        wall_h = 80
        for x in range(0, 750, 10):
            color = WALL_CORRUGATED_DARK if (x // 10) % 2 == 0 else WALL_CORRUGATED_LIGHT
            pygame.draw.rect(self.screen, color, (x, 0, 10, wall_h))
        pygame.draw.rect(self.screen, (20,22,25), (0, wall_h, 750, 10))
        office_rect = pygame.Rect(325, 20, 150, 60)
        pygame.draw.rect(self.screen, (30,35,40), office_rect, border_radius=5)
        glow_surf = pygame.Surface((130, 40), pygame.SRCALPHA)
        glow_surf.fill(CONTROL_ROOM_GLOW)
        self.screen.blit(glow_surf, (335, 30))
        pygame.draw.rect(self.screen, (100, 110, 120), office_rect, 2, border_radius=5)
        font = pygame.font.SysFont("Arial", 8)
        self.screen.blit(font.render("CONTROL", True, (150, 160, 170)), (375, 22))
        for x in [50, 150, 550, 650]:
            pygame.draw.rect(self.screen, (20, 22, 25), (x, 30, 60, 30))
            pygame.draw.rect(self.screen, (10, 12, 15), (x+5, 35, 50, 20))
        pygame.draw.line(self.screen, STRIPE_YELLOW, (250, 100), (250, SCREEN_HEIGHT), 2)
        pygame.draw.line(self.screen, STRIPE_YELLOW, (500, 100), (500, SCREEN_HEIGHT), 2)
        slot_height = CRATE_WIDTH + PARKING_GAP
        for i in range(10):
            y = STACK_ZONE_BASE_Y - (i * slot_height)
            slot_rect = pygame.Rect(STACK_ZONE_X - 10, y - CRATE_WIDTH//2, CRATE_HEIGHT + 20, CRATE_WIDTH + 10)
            c_len = 15; col = PARKING_LINE_COLOR
            pygame.draw.line(self.screen, col, slot_rect.topleft, (slot_rect.left + c_len, slot_rect.top), 2)
            pygame.draw.line(self.screen, col, slot_rect.topleft, (slot_rect.left, slot_rect.top + c_len), 2)
            pygame.draw.line(self.screen, col, (slot_rect.left, slot_rect.bottom - c_len), (slot_rect.left, slot_rect.bottom), 2)
            pygame.draw.line(self.screen, col, (slot_rect.left - c_len//2, slot_rect.bottom), (slot_rect.left + c_len//2, slot_rect.bottom), 2)
            pygame.draw.line(self.screen, col, slot_rect.topright, (slot_rect.right - c_len, slot_rect.top), 2)
            pygame.draw.line(self.screen, col, slot_rect.topright, (slot_rect.right, slot_rect.top + c_len), 2)
            pygame.draw.line(self.screen, col, (slot_rect.right, slot_rect.bottom - c_len), (slot_rect.right, slot_rect.bottom), 2)
            pygame.draw.line(self.screen, col, (slot_rect.right - c_len//2, slot_rect.bottom), (slot_rect.right + c_len//2, slot_rect.bottom), 2)
            num_font = pygame.font.SysFont("Arial", 10, bold=True)
            self.screen.blit(num_font.render(str(i+1), True, (150, 150, 160)), (slot_rect.right + 15, slot_rect.centery - 5))
        for i in range(10):
            y = HOLDING_ZONE_Y - (i * slot_height)
            slot_rect = pygame.Rect(HOLDING_ZONE_X - 10, y - CRATE_WIDTH//2, CRATE_HEIGHT + 20, CRATE_WIDTH + 10)
            pygame.draw.rect(self.screen, STRIPE_YELLOW, slot_rect, 1)
        font = pygame.font.SysFont("Impact", 18)
        text_surf = font.render("MAINTENANCE BAY", True, STENCIL_TEXT_COLOR)
        text_surf = pygame.transform.rotate(text_surf, 90)
        self.screen.blit(text_surf, (STACK_ZONE_X - 40, 350))
        text_surf = font.render("TEMP PARKING", True, STENCIL_TEXT_COLOR)
        text_surf = pygame.transform.rotate(text_surf, 90)
        self.screen.blit(text_surf, (HOLDING_ZONE_X + 130, 380))
        self.draw_pallet(20, 120, boxes=1); self.draw_pallet(60, 120, boxes=2)
        self.draw_pallet(20, 160, boxes=2); self.draw_vent(100, 130)
        self.draw_pallet(680, 120, boxes=2); self.draw_pallet(680, 160, boxes=1)
        self.draw_vent(640, 130)
    def _force_park_orientation(self, sprite):
        sprite.angle = 0
        sprite.image = pygame.transform.rotate(sprite.original_image, 0)
        self.process_next_event()
    def action_arrive(self):
        if self.is_animating or self.show_summary: return
        plate = self.lcd.text.upper()
        if not plate: self.lcd.update_status("ERR: NO INPUT"); return
        if len(plate) > 10:
            self.lcd.update_status("ERR: MAX 10 CHARS")
            return
        receipt = self.logic.push(plate)
        if receipt['type'] in ['OVERFLOW', 'DUPLICATE']:
            self.lcd.update_status(f"ERR: {receipt['message']}")
            return
        self.lcd.update_status(f"IN: {plate}")
        self.lcd.text = ""
        new_crate = CrateSprite(SPAWN_X, SPAWN_Y, receipt['data'].plate)
        self.all_sprites.add(new_crate)
        self.crates_group.add(new_crate)
        self.visual_stack.append(new_crate)
        slot_height = CRATE_WIDTH + PARKING_GAP
        stack_target_y = STACK_ZONE_BASE_Y - (receipt['index'] * slot_height)
        stack_target = (STACK_ZONE_X + CRATE_HEIGHT/2, stack_target_y)
        def drive_to_stack():
            new_crate.move_to(stack_target, callback=lambda: self._force_park_orientation(new_crate))
        self.is_animating = True
        new_crate.move_to((RECEIVING_BAY_X, RECEIVING_BAY_Y), callback=drive_to_stack)
    def action_depart(self):
        if self.is_animating or self.show_summary: return
        plate = self.lcd.text.upper()
        if not plate: return
        events = self.logic.remove_vehicle(plate)
        if events[0]['type'] == 'ERROR':
            self.lcd.update_status(f"ERR: {events[0]['message']}")
            return
        self.lcd.update_status(f"OUT: {plate}")
        self.lcd.text = ""
        self.event_queue = events
        self.is_animating = True
        self.process_next_event()
    def action_skip(self):
        """Resets the simulation state to match the logic state instantly."""
        if not self.is_animating: return
        self.event_queue = []
        for s in self.crates_group: s.kill()
        self.visual_stack = []
        slot_height = CRATE_WIDTH + PARKING_GAP
        for i, vehicle in enumerate(self.logic.items):
            new_sprite = CrateSprite(0, 0, vehicle.plate)
            target_y = STACK_ZONE_BASE_Y - (i * slot_height)
            new_sprite.pos_x = STACK_ZONE_X + CRATE_HEIGHT/2
            new_sprite.pos_y = target_y
            new_sprite.rect.center = (int(new_sprite.pos_x), int(new_sprite.pos_y))
            new_sprite.angle = 0
            new_sprite.image = pygame.transform.rotate(new_sprite.original_image, 0)
            new_sprite.is_moving = False
            self.all_sprites.add(new_sprite)
            self.crates_group.add(new_sprite)
            self.visual_stack.append(new_sprite)
        self.holding_stack_height = 0
        self.is_animating = False
        self.lcd.update_status("READY")
    def process_next_event(self):
        if not self.event_queue: self.on_animation_complete(); return
        event = self.event_queue.pop(0)
        slot_height = CRATE_WIDTH + PARKING_GAP
        if event['type'] == 'TEMP_POP':
            if self.visual_stack:
                crate = self.visual_stack.pop()
                target_y = HOLDING_ZONE_Y - (self.holding_stack_height * slot_height)
                self.holding_stack_height += 1
                crate.move_to((HOLDING_ZONE_X + CRATE_HEIGHT/2, target_y), callback=lambda: self._force_park_orientation(crate))
            else: self.process_next_event()
        elif event['type'] == 'FINAL_POP':
            if self.visual_stack:
                crate = self.visual_stack.pop()
                self.last_receipt = event['stats']
                self.last_receipt['plate'] = event['data'].plate
                def cleanup(): crate.kill(); self.process_next_event()
                crate.move_to((SHIPPING_BAY_X, SHIPPING_BAY_Y), callback=cleanup)
            else: self.process_next_event()
        elif event['type'] == 'RESTACK_PUSH':
            sprite_to_move = next((s for s in self.crates_group if hasattr(s, 'plate') and s.plate == event['data'].plate), None)
            if sprite_to_move:
                self.holding_stack_height -= 1
                target_y = STACK_ZONE_BASE_Y - (event['index'] * slot_height)
                self.visual_stack.append(sprite_to_move)
                sprite_to_move.move_to((STACK_ZONE_X + CRATE_HEIGHT/2, target_y), callback=lambda: self._force_park_orientation(sprite_to_move))
            else: self.process_next_event()
    def action_summary(self): self.show_summary = not self.show_summary
    def on_animation_complete(self): self.is_animating = False; self.lcd.update_status("READY")
    def handle_events(self, event):
        if self.show_summary:
            if event.type == pygame.MOUSEBUTTONDOWN: self.show_summary = False
            return
        self.lcd.handle_event(event); self.btn_arrive.handle_event(event)
        self.btn_depart.handle_event(event); self.btn_summary.handle_event(event)
        self.btn_skip.handle_event(event)
    def update(self):
        if self.show_summary: return
        self.all_sprites.update(); self.lcd.update()
    def draw_summary_overlay(self):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT)); overlay.set_alpha(230); overlay.fill((20, 25, 30))
        self.screen.blit(overlay, (0, 0))
        font_title = pygame.font.SysFont("Arial", 24, bold=True); font_mono = pygame.font.SysFont("Courier New", 14)
        pygame.draw.rect(self.screen, (50, 150, 250), (0, 40, SCREEN_WIDTH, 50))
        title = font_title.render("WAREHOUSE INVENTORY MANIFEST", True, (255, 255, 255))
        self.screen.blit(title, (SCREEN_WIDTH//2 - title.get_width()//2, 55))
        headers = f"{'PLATE ID':<15} {'ARRIVALS':<10} {'DEPARTURES':<10}"
        self.screen.blit(font_mono.render(headers, True, (100, 200, 255)), (SCREEN_WIDTH//2 - 150, 120))
        pygame.draw.line(self.screen, (100, 200, 255), (SCREEN_WIDTH//2 - 160, 135), (SCREEN_WIDTH//2 + 160, 135), 1)
        report = self.logic.get_inventory_report(); start_y = 150
        for i, item in enumerate(report):
            txt = f"{item['plate']:<15} {item['arrivals']:<10} {item['departures']:<10}"
            col = (255, 255, 255) if i % 2 == 0 else (200, 200, 210)
            self.screen.blit(font_mono.render(txt, True, col), (SCREEN_WIDTH//2 - 150, start_y + i*20))
    def draw(self):
        self.draw_environment()
        self.all_sprites.draw(self.screen)
        for sprite in self.crates_group:
            label_x = sprite.rect.centerx - sprite.label_surf.get_width() // 2
            label_y = sprite.rect.centery - 35
            self.screen.blit(sprite.label_surf, (label_x, label_y))
        self.chassis.draw(self.screen)
        self.lcd.draw(self.screen)
        self.btn_arrive.draw(self.screen)
        self.btn_depart.draw(self.screen)
        self.btn_summary.draw(self.screen)
        self.btn_skip.draw(self.screen)
        if self.show_summary:
            self.draw_summary_overlay()
</file>

<file path="Full_Stack_Sim/simulation/site_recursion_lab.py/site_recursion_lab.py">
import pygame
import random
import math
from settings import *
from core.ui import HandheldChassis, LCDDisplay, RoundButton, Button
class RecursionManager:
    def __init__(self):
        self.num_disks = 0
    def generate_moves_from_current_state(self, num_disks, current_pegs, destination_peg):
        self.num_disks = num_disks
        moves = []
        def find_disk(disk_val, pegs):
            for peg_name, disk_list in pegs.items():
                if disk_val in disk_list: return peg_name
            return None
        def _solve(n, dest):
            if n == 0: return
            src = find_disk(n, current_pegs)
            aux = [p for p in ['A', 'B', 'C'] if p != src and p != dest][0]
            if src == dest:
                _solve(n - 1, dest)
            else:
                _solve(n - 1, aux)
                moves.append({'from': src, 'to': dest})
                current_pegs[src].remove(n)
                current_pegs[dest].append(n)
                _solve(n - 1, dest)
        _solve(num_disks, destination_peg)
        return moves
class DiskSprite(pygame.sprite.Sprite):
    def __init__(self, value, max_value, height, color):
        super().__init__()
        self.value = value
        min_width = 80; max_width = 240
        self.width = int(min_width + (value / max_value) * (max_width - min_width))
        self.height = height; self.color = color
        self.pos_x, self.pos_y = 0.0, 0.0; self.target_x, self.target_y = 0.0, 0.0
        self.is_moving = False; self.on_finish_callback = None; self.attached_to = None
        self.is_dropping = False
        self.is_bouncing = False
        self.drop_velocity = 0.0
        self.gravity = 0.8
        self.bounce_factor = -0.4
        self.image = self._create_surface()
        self.rect = self.image.get_rect(midbottom=(0,0))
    def _create_surface(self):
        padding = 8
        surf = pygame.Surface((self.width + padding, self.height + padding), pygame.SRCALPHA)
        shadow_rect = pygame.Rect(padding, padding, self.width, self.height)
        pygame.draw.rect(surf, (0,0,0,50), shadow_rect, border_radius=4)
        main_rect = pygame.Rect(0, 0, self.width, self.height)
        dark_color = (self.color[0] * 0.7, self.color[1] * 0.7, self.color[2] * 0.7)
        highlight_color = (min(255, self.color[0] * 1.2), min(255, self.color[1] * 1.2), min(255, self.color[2] * 1.2))
        pygame.draw.rect(surf, self.color, main_rect, border_radius=4)
        pygame.draw.rect(surf, highlight_color, (0, 0, self.width, self.height // 4), border_top_left_radius=4, border_top_right_radius=4)
        for i in range(int(self.width * 0.1), int(self.width * 0.9), 12):
            pygame.draw.line(surf, dark_color, (i, 0), (i, self.height), 1)
        corner_size = 6
        pygame.draw.rect(surf, dark_color, (0,0,corner_size, corner_size))
        pygame.draw.rect(surf, dark_color, (self.width-corner_size,0,corner_size, corner_size))
        pygame.draw.rect(surf, dark_color, (0,self.height-corner_size,corner_size, corner_size))
        pygame.draw.rect(surf, dark_color, (self.width-corner_size,self.height-corner_size,corner_size, corner_size))
        pygame.draw.rect(surf, (20,20,20,150), main_rect, 2, border_radius=4)
        font_size = int(self.height * 0.7)
        try: font = pygame.font.SysFont("Impact", font_size)
        except: font = pygame.font.SysFont("Arial", font_size - 4, bold=True)
        text_surf = font.render(str(self.value), True, (255, 255, 255, 180))
        shadow_surf = font.render(str(self.value), True, (0, 0, 0, 80))
        text_rect = text_surf.get_rect(center=main_rect.center)
        surf.blit(shadow_surf, (text_rect.x + 2, text_rect.y + 2))
        surf.blit(text_surf, text_rect)
        return surf
    def move_to(self, target_pos, callback=None):
        self.target_x, self.target_y = target_pos; self.is_moving = True; self.on_finish_callback = callback
    def drop_to(self, target_pos, callback=None):
        self.target_x, self.target_y = target_pos
        self.is_dropping = True
        self.on_finish_callback = callback
    def update(self, speed_multiplier=1.0):
        padding = 8
        offset_x = padding // 2
        offset_y = padding
        if self.attached_to:
            self.rect.midtop = (int(self.attached_to.pos_x + offset_x), self.attached_to.rect.bottom)
            return
        if self.is_dropping:
            self.drop_velocity += self.gravity
            self.pos_y += self.drop_velocity
            if self.pos_y >= self.target_y:
                self.pos_y = self.target_y
                self.is_dropping = False
                self.is_bouncing = True
                self.drop_velocity *= self.bounce_factor
            self.rect.midbottom = (int(self.pos_x + offset_x), int(self.pos_y + offset_y))
            return
        if self.is_bouncing:
            self.drop_velocity += self.gravity
            self.pos_y += self.drop_velocity
            if self.pos_y >= self.target_y:
                self.pos_y = self.target_y
                self.is_bouncing = False
                self.drop_velocity = 0
                if self.on_finish_callback:
                    cb = self.on_finish_callback
                    self.on_finish_callback = None
                    cb()
            self.rect.midbottom = (int(self.pos_x + offset_x), int(self.pos_y + offset_y))
            return
        if not self.is_moving:
            self.rect.midbottom = (int(self.pos_x + offset_x), int(self.pos_y + offset_y))
            return
        dx = self.target_x - self.pos_x; dy = self.target_y - self.pos_y
        dist_sq = dx**2 + dy**2
        effective_speed = MIN_SPEED * speed_multiplier
        if dist_sq < effective_speed**2:
            self.pos_x, self.pos_y = self.target_x, self.target_y; self.is_moving = False
            if self.on_finish_callback: cb = self.on_finish_callback; self.on_finish_callback = None; cb()
        else:
            effective_lerp = LERP_FACTOR * speed_multiplier
            self.pos_x += dx * effective_lerp; self.pos_y += dy * effective_lerp
        self.rect.midbottom = (int(self.pos_x + offset_x), int(self.pos_y + offset_y))
class MagneticCraneSprite(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.trolley_width, self.trolley_height = 80, 25
        self.magnet_width, self.magnet_height = 40, 20
        self.min_cable_length = 20
        self.pos_x, self.pos_y = float(x), float(y); self.target_x, self.target_y = float(x), float(y)
        self.is_moving = False; self.move_callback = None
        self.cable_length = self.min_cable_length
        self.target_cable_length = self.min_cable_length
        self.is_hoisting = False; self.hoist_callback = None
        self.magnet_active = False
        self.image = self._create_surface()
        self.rect = self.image.get_rect(midtop=(x, y))
    def _create_surface(self):
        total_height = self.trolley_height + self.cable_length + self.magnet_height
        surf = pygame.Surface((self.trolley_width, total_height), pygame.SRCALPHA)
        trolley_rect = pygame.Rect(0, 0, self.trolley_width, self.trolley_height)
        pygame.draw.rect(surf, (80, 85, 90), trolley_rect, border_radius=3)
        pygame.draw.rect(surf, (50, 55, 60), trolley_rect, 2, border_radius=3)
        pygame.draw.rect(surf, (40,40,45), (5, -4, 10, 8)); pygame.draw.rect(surf, (40,40,45), (self.trolley_width - 15, -4, 10, 8))
        center_x = self.trolley_width / 2
        cable_end_y = self.trolley_height + self.cable_length
        pygame.draw.line(surf, (50, 55, 60), (center_x - 10, self.trolley_height), (center_x - 10, cable_end_y), 2)
        pygame.draw.line(surf, (50, 55, 60), (center_x + 10, self.trolley_height), (center_x + 10, cable_end_y), 2)
        magnet_rect = pygame.Rect(center_x - self.magnet_width/2, cable_end_y, self.magnet_width, self.magnet_height)
        pygame.draw.rect(surf, (80, 85, 90), magnet_rect, border_radius=3)
        pygame.draw.rect(surf, (50, 55, 60), magnet_rect, 2, border_radius=3)
        if self.magnet_active:
            glow_rect = magnet_rect.inflate(10, 10)
            glow_surf = pygame.Surface(glow_rect.size, pygame.SRCALPHA)
            pygame.draw.rect(glow_surf, (255, 200, 0, 100), glow_surf.get_rect(), border_radius=8)
            surf.blit(glow_surf, (glow_rect.x - magnet_rect.x, glow_rect.y - magnet_rect.y))
        return surf
    def set_magnet(self, active):
        if self.magnet_active != active: self.magnet_active = active; self.image = self._create_surface()
    def move_to(self, target_pos, callback=None):
        self.target_x, self.target_y = target_pos; self.is_moving = True; self.move_callback = callback
    def set_hoist_length(self, length, callback=None):
        self.target_cable_length = max(self.min_cable_length, length)
        self.is_hoisting = True; self.hoist_callback = callback
    def update(self, speed_multiplier=1.0):
        moved = False
        if self.is_moving:
            dx = self.target_x - self.pos_x; dy = self.target_y - self.pos_y
            if (dx**2 + dy**2) < (MIN_SPEED * speed_multiplier)**2:
                self.pos_x, self.pos_y = self.target_x, self.target_y; self.is_moving = False
                if self.move_callback: cb = self.move_callback; self.move_callback = None; cb()
            else:
                self.pos_x += dx * LERP_FACTOR * speed_multiplier; self.pos_y += dy * LERP_FACTOR * speed_multiplier
            moved = True
        if self.is_hoisting:
            dc = self.target_cable_length - self.cable_length
            if abs(dc) < MIN_SPEED * speed_multiplier:
                self.cable_length = self.target_cable_length; self.is_hoisting = False
                if self.hoist_callback: cb = self.hoist_callback; self.hoist_callback = None; cb()
            else:
                self.cable_length += dc * LERP_FACTOR * speed_multiplier
            moved = True
        if moved:
            self.image = self._create_surface()
            self.rect = self.image.get_rect(midtop=(int(self.pos_x), int(self.pos_y)))
class RecursionSimulation:
    def __init__(self, screen):
        self.screen = screen; self.logic = RecursionManager()
        self.SIM_WIDTH = 750; self.FLOOR_Y = SCREEN_HEIGHT - 80
        self.DISK_HEIGHT = 40; self.GANTRY_Y = 80
        self.TRAVEL_Y = self.GANTRY_Y
        self.all_sprites = pygame.sprite.Group(); self.disks = pygame.sprite.Group()
        self.crane = MagneticCraneSprite(self.SIM_WIDTH / 2, self.TRAVEL_Y)
        self.all_sprites.add(self.crane)
        self.ui_x = 750; self.ui_w = 250
        self.chassis = HandheldChassis(self.ui_x + 10, 20, self.ui_w - 20, SCREEN_HEIGHT - 40)
        self.lcd = LCDDisplay(self.ui_x + 35, 80, self.ui_w - 70, 100)
        btn_cx = self.ui_x + self.ui_w // 2
        self.btn_load = RoundButton(btn_cx, 280, 45, BTN_BLUE_BASE, BTN_BLUE_LIGHT, "LOAD", self.action_load)
        self.btn_solve = RoundButton(btn_cx, 390, 45, BTN_GREEN_BASE, BTN_GREEN_LIGHT, "SOLVE", self.action_solve)
        self.btn_reset = RoundButton(btn_cx, 500, 45, BTN_RED_BASE, BTN_RED_LIGHT, "RESET", self.action_reset)
        self.speed_levels = [0.5, 1.0, 2.0, 4.0, 8.0]
        self.speed_index = 1
        self.speed_multiplier = self.speed_levels[self.speed_index]
        speed_btn_y = self.chassis.rect.bottom - 60
        speed_btn_w = 80
        speed_btn_h = 30
        self.btn_speed_down = Button(btn_cx - speed_btn_w - 5, speed_btn_y, speed_btn_w, speed_btn_h, "Speed -", self.decrease_speed)
        self.btn_speed_up = Button(btn_cx + 5, speed_btn_y, speed_btn_w, speed_btn_h, "Speed +", self.increase_speed)
        self.game_state = 'IDLE'; self.selected_disk = None; self.source_peg = None
        self.move_count = 0; self.auto_solve_queue = []; self.show_win_manifest = False
        self.disks_to_load = []
        self.visual_pegs = {'A': [], 'B': [], 'C': []}
        self.peg_coords = {'A': self.SIM_WIDTH * 0.2, 'B': self.SIM_WIDTH * 0.5, 'C': self.SIM_WIDTH * 0.8}
        self.peg_rects = {p: pygame.Rect(x - 130, self.TRAVEL_Y, 260, self.FLOOR_Y - self.TRAVEL_Y) for p, x in self.peg_coords.items()}
        self.background = self._generate_static_background()
        self.action_reset()
    def _generate_static_background(self):
        bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        for y in range(self.FLOOR_Y):
            ratio = y / self.FLOOR_Y
            c = (int(20 + 20*ratio), int(25 + 20*ratio), int(30 + 20*ratio))
            pygame.draw.line(bg, c, (0, y), (SCREEN_WIDTH, y))
        for i in range(4, 0, -1):
            alpha = 30 + (i * 20)
            shelf_color = (80, 85, 90)
            box_color = (120, 90, 40)
            for y in range(150, self.FLOOR_Y, 70):
                pygame.draw.line(bg, shelf_color, (0, y), (SCREEN_WIDTH, y), 2)
                for x in range(20, SCREEN_WIDTH, 120):
                    if random.random() > 0.5:
                        bx = x + i*10 + random.randint(-10, 10)
                        by = y - 35
                        pygame.draw.rect(bg, box_color, (bx, by, 30, 35))
                        pygame.draw.rect(bg, (0,0,0), (bx, by, 30, 35), 1)
        for i in range(int(SCREEN_WIDTH / 150) + 1):
            x = i * 150
            pygame.draw.rect(bg, (10, 12, 15), (x+30, 0, 10, self.FLOOR_Y))
            pygame.draw.rect(bg, (50, 55, 60), (x, 0, 30, self.FLOOR_Y))
            for py in range(20, self.FLOOR_Y, 40):
                pygame.draw.circle(bg, (30, 35, 40), (x+5, py), 2)
                pygame.draw.circle(bg, (30, 35, 40), (x+25, py), 2)
        pygame.draw.rect(bg, (20, 22, 25), (0, 0, SCREEN_WIDTH, self.GANTRY_Y + 30))
        pygame.draw.rect(bg, (60, 65, 70), (0, self.GANTRY_Y, SCREEN_WIDTH, 20))
        pygame.draw.line(bg, (100, 105, 110), (0, self.GANTRY_Y), (SCREEN_WIDTH, self.GANTRY_Y), 2)
        pygame.draw.line(bg, (30, 35, 40), (0, self.GANTRY_Y+20), (SCREEN_WIDTH, self.GANTRY_Y+20), 2)
        floor_rect = pygame.Rect(0, self.FLOOR_Y, SCREEN_WIDTH, SCREEN_HEIGHT - self.FLOOR_Y)
        bg.fill((30, 32, 35), floor_rect)
        for _ in range(10000):
            c = random.choice([(40, 42, 45), (25, 27, 30)])
            bg.set_at((random.randint(0, SCREEN_WIDTH - 1), random.randint(self.FLOOR_Y, SCREEN_HEIGHT - 1)), c)
        pygame.draw.line(bg, (10, 10, 10), (0, self.FLOOR_Y), (SCREEN_WIDTH, self.FLOOR_Y), 2)
        for peg, x_pos in self.peg_coords.items():
            plat_w = 240
            plat_top_h = 15
            plat_base_h = 25
            base_x = x_pos - plat_w // 2
            shadow_surf = pygame.Surface((plat_w + 40, 20), pygame.SRCALPHA)
            pygame.draw.ellipse(shadow_surf, (0, 0, 0, 150), (0, 0, plat_w + 40, 20))
            bg.blit(shadow_surf, (base_x - 20, self.FLOOR_Y + plat_base_h - 10))
            front_rect = pygame.Rect(base_x, self.FLOOR_Y, plat_w, plat_base_h)
            pygame.draw.rect(bg, (50, 55, 60), front_rect)
            pygame.draw.rect(bg, (30, 35, 40), front_rect, 2)
            clip_surf = pygame.Surface((plat_w, plat_base_h), pygame.SRCALPHA)
            clip_surf.fill((0,0,0,0))
            for i in range(-20, plat_w, 30):
                pygame.draw.polygon(clip_surf, (255, 200, 0, 180), [
                    (i, 0), (i+10, 0), (i-5, plat_base_h), (i-15, plat_base_h)
                ])
            bg.blit(clip_surf, front_rect.topleft)
            top_rect = pygame.Rect(base_x + 5, self.FLOOR_Y - plat_top_h, plat_w - 10, plat_top_h)
            pygame.draw.rect(bg, (90, 95, 100), top_rect)
            pygame.draw.rect(bg, (120, 125, 130), top_rect, 1)
            label_bg_radius = 15
            pygame.draw.circle(bg, (20, 20, 20), (int(x_pos), int(self.FLOOR_Y + plat_base_h/2)), label_bg_radius)
            pygame.draw.circle(bg, (200, 200, 200), (int(x_pos), int(self.FLOOR_Y + plat_base_h/2)), label_bg_radius, 1)
            font = pygame.font.SysFont("Arial", 16, bold=True)
            text_surf = font.render(peg, True, (255, 255, 255))
            bg.blit(text_surf, (x_pos - text_surf.get_width()/2, self.FLOOR_Y + plat_base_h/2 - text_surf.get_height()/2))
        light_layer = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        light_layer.fill((0, 0, 0, 80))
        for x_pos in self.peg_coords.values():
            lx, ly = x_pos, 40
            cone_color = (220, 230, 255)
            points = [
                (lx - 10, ly), (lx + 10, ly),
                (x_pos + 100, self.FLOOR_Y), (x_pos - 100, self.FLOOR_Y)
            ]
            pygame.draw.polygon(light_layer, (*cone_color, 15), points)
            points_inner = [
                (lx - 5, ly), (lx + 5, ly),
                (x_pos + 60, self.FLOOR_Y), (x_pos - 60, self.FLOOR_Y)
            ]
            pygame.draw.polygon(light_layer, (*cone_color, 25), points_inner)
            spot_w, spot_h = 200, 40
            spot_rect = pygame.Rect(x_pos - spot_w//2, self.FLOOR_Y - spot_h//2, spot_w, spot_h)
            pygame.draw.ellipse(light_layer, (*cone_color, 40), spot_rect)
            pygame.draw.rect(bg, (20, 20, 20), (lx - 15, ly - 5, 30, 10))
            pygame.draw.ellipse(bg, (200, 255, 255), (lx - 10, ly, 20, 6))
        bg.blit(light_layer, (0,0))
        return bg
    def increase_speed(self):
        if self.speed_index < len(self.speed_levels) - 1:
            self.speed_index += 1
            self.speed_multiplier = self.speed_levels[self.speed_index]
            self.lcd.update_status(f"SPEED: {self.speed_multiplier}x")
    def decrease_speed(self):
        if self.speed_index > 0:
            self.speed_index -= 1
            self.speed_multiplier = self.speed_levels[self.speed_index]
            self.lcd.update_status(f"SPEED: {self.speed_multiplier}x")
    def action_load(self):
        if self.game_state == 'ANIMATING': return
        try:
            num_disks = int(self.lcd.text)
            if not 3 <= num_disks <= 7: self.lcd.update_status("ERR: USE 3-7 DISKS"); return
        except ValueError: self.lcd.update_status("ERR: INVALID NUMBER"); return
        self.action_reset()
        self.logic.num_disks = num_disks
        colors = [CONTAINER_RED, CONTAINER_BLUE, (180, 120, 40), (80, 80, 80), (50, 100, 60), (100, 50, 120), (120, 120, 50)]
        for i in range(num_disks):
            disk_val = num_disks - i
            config = {
                'value': disk_val, 'max_value': num_disks, 'height': self.DISK_HEIGHT,
                'color': colors[i % len(colors)],
                'target_x': self.peg_coords['A'],
                'target_y': self.FLOOR_Y - (i * self.DISK_HEIGHT)
            }
            self.disks_to_load.append(config)
        self.game_state = 'ANIMATING'
        self.lcd.update_status("LOADING CONTAINERS...")
        self.animate_next_disk_drop()
    def animate_next_disk_drop(self):
        if not self.disks_to_load:
            self.game_state = 'IDLE'
            self.update_lcd_status()
            return
        config = self.disks_to_load.pop(0)
        disk = DiskSprite(config['value'], config['max_value'], config['height'], config['color'])
        disk.pos_x = config['target_x']
        disk.pos_y = -50
        self.all_sprites.add(disk); self.disks.add(disk)
        def on_drop_complete():
            self.visual_pegs['A'].append(disk)
            self.animate_next_disk_drop()
        disk.drop_to((config['target_x'], config['target_y']), on_drop_complete)
    def action_solve(self):
        if self.game_state != 'IDLE' or self.logic.num_disks == 0: return
        self.game_state = 'ANIMATING'; self.lcd.update_status("CALCULATING...")
        current_peg_state = {p: [d.value for d in disks] for p, disks in self.visual_pegs.items()}
        self.auto_solve_queue = self.logic.generate_moves_from_current_state(self.logic.num_disks, current_peg_state, 'C')
        if self.auto_solve_queue: self.lcd.update_status("AUTO-SOLVING..."); self.process_next_auto_move()
        else: self.game_state = 'IDLE'; self.check_win_condition()
    def action_reset(self):
        self.game_state = 'IDLE'; self.selected_disk = None; self.source_peg = None
        self.move_count = 0; self.logic.num_disks = 0; self.auto_solve_queue.clear()
        self.disks_to_load.clear()
        self.show_win_manifest = False
        for disk in self.disks: disk.kill()
        self.visual_pegs = {'A': [], 'B': [], 'C': []}
        self.crane.move_to((self.SIM_WIDTH / 2, self.TRAVEL_Y)); self.crane.set_magnet(False)
        self.crane.set_hoist_length(self.crane.min_cable_length)
        self.lcd.update_status("LOAD DISKS [3-7]")
    def update_lcd_status(self):
        if self.game_state == 'IDLE': self.lcd.update_status(f"MOVES: {self.move_count} | SELECT DISK")
        elif self.game_state == 'DISK_SELECTED': self.lcd.update_status(f"MOVES: {self.move_count} | SELECT PEG")
        elif self.game_state == 'WIN': self.lcd.update_status(f"SOLVED IN {self.move_count} MOVES!")
    def handle_mouse_click(self, pos):
        if self.game_state == 'IDLE':
            for peg_name, peg_disks in self.visual_pegs.items():
                if peg_disks and peg_disks[-1].rect.collidepoint(pos):
                    self.source_peg = peg_name; self.selected_disk = peg_disks[-1]
                    self.game_state = 'ANIMATING'; self.animate_pickup()
                    return
        elif self.game_state == 'DISK_SELECTED':
            for peg_name, rect in self.peg_rects.items():
                if rect.collidepoint(pos): self.handle_place_attempt(peg_name)
    def handle_place_attempt(self, dest_peg):
        is_valid = not self.visual_pegs[dest_peg] or self.selected_disk.value < self.visual_pegs[dest_peg][-1].value
        self.game_state = 'ANIMATING'
        if is_valid: self.animate_place(dest_peg)
        else: self.lcd.update_status("INVALID MOVE! RETURNING..."); self.animate_return()
    def check_win_condition(self):
        if self.logic.num_disks > 0 and (len(self.visual_pegs['C']) == self.logic.num_disks or len(self.visual_pegs['B']) == self.logic.num_disks):
            self.game_state = 'WIN'; self.show_win_manifest = True; return True
        return False
    def animate_pickup(self):
        pickup_x = self.peg_coords[self.source_peg]
        disk_center_y = self.selected_disk.rect.centery
        disk_top_y = disk_center_y - self.DISK_HEIGHT / 2
        target_cable_len = disk_top_y - self.TRAVEL_Y - self.crane.trolley_height - self.crane.magnet_height
        def on_rise(): self.game_state = 'DISK_SELECTED'; self.update_lcd_status()
        def on_attach(): self.selected_disk.attached_to = self.crane; self.crane.set_magnet(True); self.crane.set_hoist_length(self.crane.min_cable_length, callback=on_rise)
        def on_lower(): self.crane.set_hoist_length(target_cable_len, callback=on_attach)
        self.crane.move_to((pickup_x, self.TRAVEL_Y), callback=on_lower)
    def animate_place(self, dest_peg):
        dest_x = self.peg_coords[dest_peg]
        dest_y_bottom = self.FLOOR_Y - (len(self.visual_pegs[dest_peg]) * self.DISK_HEIGHT)
        disk_top_y = dest_y_bottom - self.DISK_HEIGHT
        target_cable_len = disk_top_y - self.TRAVEL_Y - self.crane.trolley_height - self.crane.magnet_height
        def on_placed():
            self.visual_pegs[dest_peg].append(self.visual_pegs[self.source_peg].pop())
            self.selected_disk = None; self.source_peg = None; self.move_count += 1
            if not self.check_win_condition(): self.game_state = 'IDLE'
            self.update_lcd_status()
        def on_detach():
            self.selected_disk.pos_x = dest_x
            self.selected_disk.pos_y = dest_y_bottom
            self.selected_disk.attached_to = None
            self.crane.set_magnet(False)
            self.crane.set_hoist_length(self.crane.min_cable_length, callback=on_placed)
        def on_lower(): self.crane.set_hoist_length(target_cable_len, callback=on_detach)
        self.crane.move_to((dest_x, self.TRAVEL_Y), callback=on_lower)
    def animate_return(self):
        dest_x = self.peg_coords[self.source_peg]
        dest_y_bottom = self.FLOOR_Y - ((len(self.visual_pegs[self.source_peg]) - 1) * self.DISK_HEIGHT)
        disk_top_y = dest_y_bottom - self.DISK_HEIGHT
        target_cable_len = disk_top_y - self.TRAVEL_Y - self.crane.trolley_height - self.crane.magnet_height
        def on_returned():
            self.selected_disk = None; self.source_peg = None; self.game_state = 'IDLE'; self.update_lcd_status()
        def on_detach():
            self.selected_disk.pos_x = dest_x
            self.selected_disk.pos_y = dest_y_bottom
            self.selected_disk.attached_to = None
            self.crane.set_magnet(False)
            self.crane.set_hoist_length(self.crane.min_cable_length, callback=on_returned)
        def on_lower(): self.crane.set_hoist_length(target_cable_len, callback=on_detach)
        self.crane.move_to((dest_x, self.TRAVEL_Y), callback=on_lower)
    def process_next_auto_move(self):
        if not self.auto_solve_queue:
            self.game_state = 'IDLE'
            if not self.check_win_condition(): self.lcd.update_status("AUTO-SOLVE FINISHED!")
            else: self.update_lcd_status()
            self.crane.set_magnet(False)
            return
        move = self.auto_solve_queue.pop(0)
        from_peg, to_peg = move['from'], move['to']
        disk = self.visual_pegs[from_peg][-1]
        source_x = self.peg_coords[from_peg]; dest_x = self.peg_coords[to_peg]
        source_disk_top_y = self.FLOOR_Y - ((len(self.visual_pegs[from_peg]) - 1) * self.DISK_HEIGHT) - self.DISK_HEIGHT
        dest_disk_top_y = self.FLOOR_Y - (len(self.visual_pegs[to_peg]) * self.DISK_HEIGHT) - self.DISK_HEIGHT
        pickup_cable_len = source_disk_top_y - self.TRAVEL_Y - self.crane.trolley_height - self.crane.magnet_height
        place_cable_len = dest_disk_top_y - self.TRAVEL_Y - self.crane.trolley_height - self.crane.magnet_height
        def on_raised_final(): self.process_next_auto_move()
        def on_placed():
            disk.pos_x = dest_x; disk.pos_y = self.FLOOR_Y - (len(self.visual_pegs[to_peg]) * self.DISK_HEIGHT)
            self.visual_pegs[to_peg].append(self.visual_pegs[from_peg].pop()); self.move_count += 1; self.update_lcd_status()
            self.crane.set_hoist_length(self.crane.min_cable_length, callback=on_raised_final)
        def on_detach(): disk.attached_to = None; self.crane.set_magnet(False); on_placed()
        def on_lower_to_place(): self.crane.set_hoist_length(place_cable_len, callback=on_detach)
        def on_move_horizontally(): on_lower_to_place()
        def on_raised_with_disk(): self.crane.move_to((dest_x, self.TRAVEL_Y), callback=on_move_horizontally)
        def on_attach(): disk.attached_to = self.crane; self.crane.set_magnet(True); self.crane.set_hoist_length(self.crane.min_cable_length, callback=on_raised_with_disk)
        def on_lower_to_pickup(): self.crane.set_hoist_length(pickup_cable_len, callback=on_attach)
        self.crane.move_to((source_x, self.TRAVEL_Y), callback=on_lower_to_pickup)
    def handle_events(self, event):
        if self.game_state == 'ANIMATING':
            self.btn_reset.handle_event(event); return
        if self.show_win_manifest:
            if event.type == pygame.MOUSEBUTTONDOWN: self.action_reset()
            return
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            self.handle_mouse_click(event.pos)
        self.lcd.handle_event(event)
        self.btn_load.handle_event(event)
        self.btn_solve.handle_event(event)
        self.btn_reset.handle_event(event)
        self.btn_speed_up.handle_event(event)
        self.btn_speed_down.handle_event(event)
    def update(self):
        if self.show_win_manifest: return
        self.all_sprites.update(self.speed_multiplier)
        self.lcd.update()
    def draw_hover_effects(self):
        if self.game_state != 'DISK_SELECTED' or not self.selected_disk: return
        mouse_pos = pygame.mouse.get_pos()
        for peg, rect in self.peg_rects.items():
            if rect.collidepoint(mouse_pos):
                # Determine validity
                is_valid = True
                if self.visual_pegs[peg]:
                    if self.selected_disk.value > self.visual_pegs[peg][-1].value:
                        is_valid = False
                # Hologram Color
                holo_color = (0, 255, 255) if is_valid else (255, 50, 50)
                # Calculate Position
                peg_x = self.peg_coords[peg]
                dest_y = self.FLOOR_Y - (len(self.visual_pegs[peg]) * self.DISK_HEIGHT)
                # Draw the hologram rect
                w, h = self.selected_disk.width, self.selected_disk.height
                ghost_rect = pygame.Rect(0, 0, w, h)
                ghost_rect.midbottom = (peg_x, dest_y)
                # Draw fill
                s = pygame.Surface((w, h), pygame.SRCALPHA)
                pygame.draw.rect(s, (*holo_color, 80), (0,0,w,h), border_radius=4)
                pygame.draw.rect(s, (*holo_color, 200), (0,0,w,h), 2, border_radius=4)
                # Scanline effect for hologram
                for i in range(0, h, 4):
                    pygame.draw.line(s, (*holo_color, 50), (0, i), (w, i), 1)
                self.screen.blit(s, ghost_rect)
                # Draw guide line from top
                pygame.draw.line(self.screen, (*holo_color, 100), (peg_x, self.TRAVEL_Y + 30), (peg_x, ghost_rect.top), 1)
                pygame.draw.circle(self.screen, holo_color, (peg_x, ghost_rect.top), 2)
    def draw_win_manifest(self):
        overlay = pygame.Surface((self.SIM_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        w, h = 450, 250; x, y = (self.SIM_WIDTH - w) // 2, (SCREEN_HEIGHT - h) // 2
        pygame.draw.rect(self.screen, (0,0,0,80), (x+5, y+5, w, h), border_radius=3)
        pygame.draw.rect(self.screen, (230, 230, 220), (x, y, w, h), border_radius=3)
        pygame.draw.rect(self.screen, (100,100,100), (x,y,w,h), 1, border_radius=3)
        font_header = pygame.font.SysFont("Impact", 30)
        header_surf = font_header.render("PUZZLE COMPLETE", True, (30,30,30))
        self.screen.blit(header_surf, (x + w//2 - header_surf.get_width()//2, y + 25))
        pygame.draw.line(self.screen, (180,180,170), (x+20, y+70), (x+w-20, y+70), 2)
        font_label = pygame.font.SysFont("Courier New", 18, bold=True)
        font_result = pygame.font.SysFont("Courier New", 20)
        moves_label = font_label.render("Total Moves:", True, (80,80,80))
        self.screen.blit(moves_label, (x + 40, y + 100))
        moves_surf = font_result.render(str(self.move_count), True, (40, 40, 40))
        self.screen.blit(moves_surf, (x + w - moves_surf.get_width() - 40, y + 100))
        optimal_moves = 2**self.logic.num_disks - 1
        optimal_label = font_label.render("Optimal Moves:", True, (80,80,80))
        self.screen.blit(optimal_label, (x + 40, y + 140))
        optimal_surf = font_result.render(str(optimal_moves), True, (40, 40, 40))
        self.screen.blit(optimal_surf, (x + w - optimal_surf.get_width() - 40, y + 140))
        font_prompt = pygame.font.SysFont("Arial", 12)
        prompt_surf = font_prompt.render("Click anywhere to reset", True, (150, 150, 150))
        self.screen.blit(prompt_surf, (x + w - prompt_surf.get_width() - 10, y + h - prompt_surf.get_height() - 10))
    def draw(self):
        self.screen.blit(self.background, (0, 0))
        self.draw_hover_effects()
        self.disks.draw(self.screen)
        self.screen.blit(self.crane.image, self.crane.rect)
        self.chassis.draw(self.screen); self.lcd.draw(self.screen)
        self.btn_load.draw(self.screen); self.btn_solve.draw(self.screen); self.btn_reset.draw(self.screen)
        self.btn_speed_up.draw(self.screen); self.btn_speed_down.draw(self.screen)
        if self.show_win_manifest:
            self.draw_win_manifest()
</file>

<file path="Full_Stack_Sim/simulation/site_router_tree.py/site_router_tree.py">
import pygame
import math
import random
from settings import *
from core.sprites import CrateSprite
from core.ui import HandheldChassis, LCDDisplay, RoundButton, Button
class BSTNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.x = 0; self.y = 0
        self.target_x = 0; self.target_y = 0
        self.push_arm_state = 'idle'
        self.push_arm_timer = 0
class BSTManager:
    def __init__(self):
        self.root = None
        self.nodes_count = 0
        self.max_allowed_depth = 5
        self.current_depth = 0
    def insert(self, value):
        if self.root is None:
            self.root = BSTNode(value)
            self.nodes_count += 1
            self.current_depth = 0
            return {"type": "ROOT", "node": self.root}
        current = self.root
        depth = 0
        path_nodes = []
        while True:
            path_nodes.append(current)
            if depth >= self.max_allowed_depth:
                return {"type": "ERROR", "message": "MAX DEPTH"}
            if value <= current.value:
                if current.left is None:
                    current.left = BSTNode(value)
                    self.nodes_count += 1
                    self.current_depth = max(self.current_depth, depth + 1)
                    return {
                        "type": "INSERT", "node": current.left, "parent": current,
                        "direction": "LEFT", "path_nodes": path_nodes
                    }
                current = current.left
            else:
                if current.right is None:
                    current.right = BSTNode(value)
                    self.nodes_count += 1
                    self.current_depth = max(self.current_depth, depth + 1)
                    return {
                        "type": "INSERT", "node": current.right, "parent": current,
                        "direction": "RIGHT", "path_nodes": path_nodes
                    }
                current = current.right
            depth += 1
    def clear(self):
        self.root = None
        self.nodes_count = 0
        self.current_depth = 0
    def in_order(self):
        result = []
        self._in_order_recursive(self.root, result)
        return result
    def _in_order_recursive(self, node, result):
        if node:
            self._in_order_recursive(node.left, result)
            result.append(node)
            self._in_order_recursive(node.right, result)
    def pre_order(self):
        result = []
        self._pre_order_recursive(self.root, result)
        return result
    def _pre_order_recursive(self, node, result):
        if node:
            result.append(node)
            self._pre_order_recursive(node.left, result)
            self._pre_order_recursive(node.right, result)
    def post_order(self):
        result = []
        self._post_order_recursive(self.root, result)
        return result
    def _post_order_recursive(self, node, result):
        if node:
            self._post_order_recursive(node.left, result)
            self._post_order_recursive(node.right, result)
            result.append(node)
class PackageSprite(pygame.sprite.Sprite):
    def __init__(self, start_x, start_y, value, size=30):
        super().__init__()
        self.value = value
        self.pos_x = float(start_x)
        self.pos_y = float(start_y)
        self.target_node = None
        self.path_queue = []
        self.final_callback = None
        self.is_moving = False
        self.image = None
        self.current_size = 0
        self.attached_node = None
        self.resize(size)
        self.rect = self.image.get_rect(center=(start_x, start_y))
    def resize(self, size):
        s = int(size)
        if s < 10: s = 10
        if abs(s - self.current_size) < 1 and self.image is not None:
            return
        self.current_size = s
        self.image = pygame.Surface((s, s), pygame.SRCALPHA)
        shadow_rect = pygame.Rect(2, 2, s, s)
        pygame.draw.rect(self.image, (0,0,0,80), shadow_rect, border_radius=3)
        main_rect = pygame.Rect(0, 0, s, s)
        pygame.draw.rect(self.image, BOX_COLOR_1, main_rect, border_radius=3)
        pygame.draw.rect(self.image, (50, 30, 10, 150), main_rect, 2, border_radius=3)
        half = s // 2
        tape_w = max(1, int(s * 0.15))
        pygame.draw.line(self.image, BOX_TAPE, (half, 0), (half, s), tape_w)
        pygame.draw.line(self.image, BOX_TAPE, (0, half), (s, half), tape_w)
        self.rect = self.image.get_rect(center=(int(self.pos_x), int(self.pos_y)))
    def add_path(self, nodes):
        self.path_queue.extend(nodes)
        if not self.is_moving and self.path_queue:
            self._start_next_leg()
    def _start_next_leg(self):
        if not self.path_queue: return
        self.target_node = self.path_queue.pop(0)
        self.is_moving = True
    def update(self):
        if self.attached_node:
            self.pos_x = self.attached_node.x
            self.pos_y = self.attached_node.y
            self.rect.center = (int(self.pos_x), int(self.pos_y))
            return
        if not self.is_moving or not self.target_node: return
        tx, ty = self.target_node.x, self.target_node.y
        dx = tx - self.pos_x
        dy = ty - self.pos_y
        dist = math.sqrt(dx**2 + dy**2)
        if dist < MIN_SPEED:
            self.pos_x, self.pos_y = tx, ty
            if self.path_queue:
                if self.target_node.left or self.target_node.right:
                    next_node = self.path_queue[0]
                    if next_node.value <= self.target_node.value:
                        self.target_node.push_arm_state = 'left'
                    else:
                        self.target_node.push_arm_state = 'right'
                    self.target_node.push_arm_timer = 15
                self._start_next_leg()
            else:
                self.is_moving = False
                self.attached_node = self.target_node
                self.target_node = None
                if self.final_callback:
                    cb = self.final_callback
                    self.final_callback = None
                    cb()
        else:
            self.pos_x += dx * LERP_FACTOR
            self.pos_y += dy * LERP_FACTOR
        self.rect.center = (int(self.pos_x), int(self.pos_y))
class DroneSprite(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.pos_x = float(x); self.pos_y = float(y)
        self.target_x = float(x); self.target_y = float(y)
        self.is_moving = False; self.on_finish_callback = None
        self.rotor_angle = 0
        self.current_size = 0
        self.original_image = None
        self.rotor_image = None
        self.image = pygame.Surface((1,1))
        self.rect = self.image.get_rect(center=(x,y))
        self.resize(40)
    def resize(self, size):
        s = int(size)
        if s < 15: s = 15
        if self.current_size == s: return
        self.current_size = s
        self.original_image = pygame.Surface((s, s), pygame.SRCALPHA)
        center = s // 2
        chassis_radius = s * 0.25
        arm_length = s * 0.5
        rotor_radius = s * 0.12
        arm_color = (80, 85, 90)
        pygame.draw.line(self.original_image, arm_color, (center, center), (center - arm_length, center - arm_length), 3)
        pygame.draw.line(self.original_image, arm_color, (center, center), (center + arm_length, center - arm_length), 3)
        pygame.draw.line(self.original_image, arm_color, (center, center), (center - arm_length, center + arm_length), 3)
        pygame.draw.line(self.original_image, arm_color, (center, center), (center + arm_length, center + arm_length), 3)
        pod_color = (50, 55, 60)
        pygame.draw.circle(self.original_image, pod_color, (center - arm_length, center - arm_length), rotor_radius)
        pygame.draw.circle(self.original_image, pod_color, (center + arm_length, center - arm_length), rotor_radius)
        pygame.draw.circle(self.original_image, pod_color, (center - arm_length, center + arm_length), rotor_radius)
        pygame.draw.circle(self.original_image, pod_color, (center + arm_length, center + arm_length), rotor_radius)
        pygame.draw.circle(self.original_image, (0,0,0,80), (center+2, center+2), chassis_radius)
        pygame.draw.circle(self.original_image, (180,185,190), (center, center), chassis_radius)
        pygame.draw.circle(self.original_image, (100,105,110), (center, center), chassis_radius, 1)
        pygame.draw.circle(self.original_image, (255, 80, 80), (center, center), chassis_radius * 0.5)
        pygame.draw.circle(self.original_image, (255, 150, 150), (center-1, center-1), chassis_radius * 0.2)
        self.rotor_image = pygame.Surface((s,s), pygame.SRCALPHA)
        blade_color = (50,55,60,180)
        blade_length = rotor_radius * 1.5
        for angle in [45, 135, 225, 315]:
            rad = math.radians(angle)
            end_x = center + math.cos(rad) * arm_length
            end_y = center + math.sin(rad) * arm_length
            pygame.draw.line(self.rotor_image, blade_color, (end_x - blade_length, end_y), (end_x + blade_length, end_y), 2)
    def move_to(self, target_pos, callback=None):
        self.target_x, self.target_y = target_pos
        self.on_finish_callback = callback
        self.is_moving = True
    def update(self):
        self.rotor_angle = (self.rotor_angle + 45) % 360
        if self.is_moving:
            dx = self.target_x - self.pos_x; dy = self.target_y - self.pos_y
            dist = math.sqrt(dx**2 + dy**2)
            if dist < 3.0:
                self.pos_x, self.pos_y = self.target_x, self.target_y
                self.is_moving = False
                if self.on_finish_callback:
                    cb = self.on_finish_callback; self.on_finish_callback = None; cb()
            else:
                self.pos_x += dx * 0.15; self.pos_y += dy * 0.15
        self.image = self.original_image.copy()
        rotated_rotors = pygame.transform.rotate(self.rotor_image, self.rotor_angle)
        rotor_rect = rotated_rotors.get_rect(center=self.image.get_rect().center)
        self.image.blit(rotated_rotors, rotor_rect)
        self.rect = self.image.get_rect(center=(int(self.pos_x), int(self.pos_y)))
class RouterTreeSimulation:
    def __init__(self, screen):
        self.screen = screen
        self.logic = BSTManager()
        self.packages_group = pygame.sprite.Group()
        self.drone = DroneSprite(-50, -50)
        self.drone_group = pygame.sprite.GroupSingle(self.drone)
        self.ui_x = 750; self.ui_w = 250
        self.chassis = HandheldChassis(self.ui_x + 10, 20, self.ui_w - 20, SCREEN_HEIGHT - 40)
        self.lcd = LCDDisplay(self.ui_x + 35, 80, self.ui_w - 70, 100)
        self.lcd.update_status("ROUTING SYSTEM")
        btn_cx = self.ui_x + self.ui_w // 2
        self.btn_insert = RoundButton(btn_cx, 280, 45, BTN_GREEN_BASE, BTN_GREEN_LIGHT, "INJECT", self.action_insert)
        self.btn_reset = RoundButton(btn_cx, 390, 45, BTN_RED_BASE, BTN_RED_LIGHT, "CLEAR", self.action_reset)
        self.btn_scan = RoundButton(btn_cx, 500, 45, BTN_BLUE_BASE, BTN_BLUE_LIGHT, "TRAVERSE", self.action_open_traversal_menu)
        self.is_animating = False
        self.SIM_WIDTH = 750; self.TOP_MARGIN = 120; self.BOTTOM_MARGIN = 50
        self.ROOT_X = self.SIM_WIDTH // 2
        self.target_node_size = 80; self.current_node_size = 80; self.belt_offset = 0
        self.bg_surface = self._generate_background()
        self.show_traversal_menu = False; self.traversal_result_data = None; self.pending_report_data = None
        menu_btn_w, menu_btn_h = 200, 40; menu_cx = self.SIM_WIDTH // 2; menu_start_y = 250
        self.menu_btn_in = Button(menu_cx - menu_btn_w//2, menu_start_y, menu_btn_w, menu_btn_h, "In-Order Traversal", lambda: self.action_traverse("IN"))
        self.menu_btn_pre = Button(menu_cx - menu_btn_w//2, menu_start_y + 50, menu_btn_w, menu_btn_h, "Pre-Order Traversal", lambda: self.action_traverse("PRE"))
        self.menu_btn_post = Button(menu_cx - menu_btn_w//2, menu_start_y + 100, menu_btn_w, menu_btn_h, "Post-Order Traversal", lambda: self.action_traverse("POST"))
        self.is_traversing = False; self.traversal_path = []; self.traversal_index = 0
        self.highlighted_node = None; self.highlight_timer = 0
    def _generate_background(self):
        bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        floor_y = SCREEN_HEIGHT
        for y in range(floor_y):
            ratio = y / floor_y
            c = (int(25 + 15*ratio), int(30 + 15*ratio), int(35 + 15*ratio))
            pygame.draw.line(bg, c, (0, y), (SCREEN_WIDTH, y))
        for i in range(int(SCREEN_WIDTH / 200) + 1):
            x = i * 200
            pygame.draw.rect(bg, (15, 18, 20), (x, 0, 40, floor_y))
            pygame.draw.rect(bg, (40, 45, 50), (x+5, 0, 30, floor_y))
            for ry in range(20, floor_y, 50):
                pygame.draw.circle(bg, (25, 30, 35), (x+10, ry), 3)
                pygame.draw.circle(bg, (25, 30, 35), (x+30, ry), 3)
        truss_y = 80
        pygame.draw.rect(bg, (20, 22, 25), (0, truss_y - 20, SCREEN_WIDTH, 40))
        for x in range(0, SCREEN_WIDTH, 40):
            pygame.draw.line(bg, (50, 55, 60), (x, truss_y - 20), (x+20, truss_y + 20), 2)
            pygame.draw.line(bg, (50, 55, 60), (x+20, truss_y - 20), (x, truss_y + 20), 2)
        pygame.draw.rect(bg, (60, 65, 70), (0, truss_y + 15, SCREEN_WIDTH, 5))
        floor_start = SCREEN_HEIGHT - 150
        floor_rect = pygame.Rect(0, floor_start, SCREEN_WIDTH, 150)
        bg.fill((30, 32, 35), floor_rect)
        for _ in range(5000):
            c = random.choice([(40, 42, 45), (25, 27, 30)])
            bg.set_at((random.randint(0, SCREEN_WIDTH - 1), random.randint(floor_start, SCREEN_HEIGHT - 1)), c)
        zone_rect = pygame.Rect(50, floor_start + 20, self.SIM_WIDTH - 100, 100)
        pygame.draw.rect(bg, (35, 35, 40), zone_rect, border_radius=10)
        pygame.draw.rect(bg, (60, 60, 60), zone_rect, 2, border_radius=10)
        for i in range(zone_rect.left, zone_rect.right, 40):
            p1 = (i, zone_rect.bottom)
            p2 = (i + 20, zone_rect.bottom)
            p3 = (i + 30, zone_rect.bottom + 10)
            p4 = (i + 10, zone_rect.bottom + 10)
            pygame.draw.polygon(bg, STRIPE_YELLOW, [p1, p2, p3, p4])
        light_layer = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        light_layer.fill((0, 0, 0, 60))
        for i in range(150, self.SIM_WIDTH, 250):
            lx, ly = i, truss_y + 20
            cone_color = (200, 255, 220)
            points = [
                (lx - 20, ly), (lx + 20, ly),
                (lx + 150, floor_start + 50), (lx - 150, floor_start + 50)
            ]
            pygame.draw.polygon(light_layer, (*cone_color, 10), points)
            points_core = [
                (lx - 5, ly), (lx + 5, ly),
                (lx + 80, floor_start + 50), (lx - 80, floor_start + 50)
            ]
            pygame.draw.polygon(light_layer, (*cone_color, 20), points_core)
            pygame.draw.rect(bg, (20, 20, 20), (lx - 15, ly - 5, 30, 10))
            pygame.draw.ellipse(bg, (220, 255, 220), (lx - 10, ly, 20, 6))
        bg.blit(light_layer, (0,0))
        return bg
    def _draw_shelf_unit(self, surf, x, y, w, h, rows, cols):
        pass
    def _draw_pillar(self, surf, x, y, w, h):
        pass
    def _recalculate_layout(self, node, x, y, level, width_spread):
        if node is None: return
        node.target_x = x; node.target_y = y
        depth = self.logic.current_depth
        level_height = (SCREEN_HEIGHT - self.TOP_MARGIN - self.BOTTOM_MARGIN) / max(1, depth) if depth > 0 else 0
        next_spread = width_spread / 2
        self._recalculate_layout(node.left, x - next_spread, y + level_height, level + 1, next_spread)
        self._recalculate_layout(node.right, x + next_spread, y + level_height, level + 1, next_spread)
    def _update_node_positions(self, node):
        if node is None: return
        dx = node.target_x - node.x; dy = node.target_y - node.y
        if abs(dx) > 0.1 or abs(dy) > 0.1:
            node.x += dx * 0.1; node.y += dy * 0.1
        else:
            node.x, node.y = node.target_x, node.target_y
        if node.push_arm_timer > 0:
            node.push_arm_timer -= 1
            if node.push_arm_timer == 0:
                node.push_arm_state = 'idle'
        self._update_node_positions(node.left); self._update_node_positions(node.right)
    def draw_conveyor_line(self, start, end):
        dist = math.hypot(end[0]-start[0], end[1]-start[1])
        if dist == 0: return
        angle = math.atan2(end[1]-start[1], end[0]-start[0]); perp_angle = angle + math.pi / 2
        w = self.current_node_size * 0.4
        dx, dy = math.cos(perp_angle) * w/2, math.sin(perp_angle) * w/2
        points = [(start[0] - dx, start[1] - dy), (start[0] + dx, start[1] + dy),
                  (end[0] + dx, end[1] + dy), (end[0] - dx, end[1] - dy)]
        pygame.draw.polygon(self.screen, (40,40,45), points)
        num_stripes = int(dist / 20)
        if num_stripes > 0:
            for i in range(num_stripes + 2):
                t = (i - self.belt_offset / 20) / num_stripes
                if 0 <= t <= 1:
                    px1 = start[0] + (end[0]-start[0]) * t; py1 = start[1] + (end[1]-start[1]) * t
                    pygame.draw.line(self.screen, (60,60,65), (px1 - dx, py1 - dy), (px1 + dx, py1 + dy), 2)
        pygame.draw.line(self.screen, (90,95,100), points[0], points[3], 5)
        pygame.draw.line(self.screen, (90,95,100), points[1], points[2], 5)
    def draw_tree_nodes_and_labels(self, node):
        if node is None: return
        if node.left:
            self.draw_conveyor_line((node.x, node.y), (node.left.x, node.left.y)); self.draw_tree_nodes_and_labels(node.left)
        if node.right:
            self.draw_conveyor_line((node.x, node.y), (node.right.x, node.right.y)); self.draw_tree_nodes_and_labels(node.right)
        s = int(self.current_node_size); rect = pygame.Rect(0, 0, s, s); rect.center = (node.x, node.y)
        base_rect = rect.inflate(s*0.2, s*0.2)
        pygame.draw.rect(self.screen, (30,30,35), base_rect.move(3,3), border_radius=5)
        pygame.draw.rect(self.screen, (80,85,90), base_rect, border_radius=5)
        arm_w, arm_h = s * 0.8, s * 0.2; arm_rect = pygame.Rect(0,0, arm_w, arm_h); arm_rect.centery = base_rect.centery
        if node.push_arm_state == 'left': arm_rect.right = base_rect.centerx - 5
        elif node.push_arm_state == 'right': arm_rect.left = base_rect.centerx + 5
        else: arm_rect.centerx = base_rect.centerx
        pygame.draw.rect(self.screen, (255, 200, 0), arm_rect); pygame.draw.rect(self.screen, (180, 140, 0), arm_rect, 2)
        pygame.draw.rect(self.screen, (150,155,160), rect, border_radius=3)
        if self.highlighted_node == node and self.highlight_timer > 0:
            pygame.draw.rect(self.screen, (255, 255, 0), base_rect, 3, border_radius=5)
        font_size = max(14, int(s * 0.5)); font = pygame.font.SysFont("Impact", font_size)
        txt = font.render(str(node.value), True, (20, 20, 20))
        self.screen.blit(txt, (rect.centerx - txt.get_width()//2, rect.centery - txt.get_height()//2))
    def action_insert(self):
        if self.is_animating or self.is_traversing: return
        text = self.lcd.text
        if not text.isdigit(): self.lcd.update_status("ERR: INTEGERS ONLY"); return
        val = int(text)
        if val > 999: self.lcd.update_status("ERR: MAX 999"); return
        receipt = self.logic.insert(val)
        if receipt['type'] == 'ERROR': self.lcd.update_status(f"ERR: {receipt['message']}"); return
        self.lcd.update_status(f"ROUTING: {val}"); self.lcd.text = ""
        self.is_animating = True
        if receipt['type'] != 'ROOT':
            new_node = receipt['node']; parent = receipt['parent']
            new_node.x, new_node.y = parent.x, parent.y
        pkg = PackageSprite(self.ROOT_X, 40, val, size=self.current_node_size * 0.7)
        self.packages_group.add(pkg)
        hopper_node = BSTNode(0); hopper_node.x = self.ROOT_X; hopper_node.y = self.TOP_MARGIN
        path_nodes = [hopper_node]
        if receipt['type'] != 'ROOT':
            path_nodes.extend(receipt['path_nodes']); path_nodes.append(receipt['node'])
        pkg.final_callback = self.on_animation_complete; pkg.add_path(path_nodes)
    def action_reset(self):
        if self.is_traversing: return
        self.logic.clear(); self.packages_group.empty()
        self.drone.move_to((-50, -50))
        self.is_animating = False; self.lcd.update_status("SYSTEM FLUSHED")
    def on_animation_complete(self):
        self.is_animating = False; self.lcd.update_status("READY")
    def action_open_traversal_menu(self):
        if self.is_animating or self.is_traversing or not self.logic.root: return
        self.show_traversal_menu = True
    def action_traverse(self, order_type):
        self.show_traversal_menu = False
        path = []; title = ""
        if order_type == "IN": path = self.logic.in_order(); title = "IN-ORDER SCAN MANIFEST"
        elif order_type == "PRE": path = self.logic.pre_order(); title = "PRE-ORDER SCAN MANIFEST"
        elif order_type == "POST": path = self.logic.post_order(); title = "POST-ORDER SCAN MANIFEST"
        self.traversal_path = path
        self.pending_report_data = {"title": title, "path": " ".join([str(node.value) for node in path])}
        self.is_traversing = True; self.traversal_index = 0
        self.drone.pos_x, self.drone.pos_y = self.ROOT_X, 20
        self.lcd.update_status("SCANNING..."); self.process_next_traversal_step()
    def process_next_traversal_step(self):
        if self.traversal_index >= len(self.traversal_path):
            self.on_traversal_complete(); return
        node_to_visit = self.traversal_path[self.traversal_index]
        self.drone.move_to((node_to_visit.x, node_to_visit.y), callback=self.on_drone_arrival)
    def on_drone_arrival(self):
        node = self.traversal_path[self.traversal_index]
        self.highlighted_node = node; self.highlight_timer = 20
        self.traversal_index += 1; self.process_next_traversal_step()
    def on_traversal_complete(self):
        self.is_traversing = False; self.traversal_path = []; self.traversal_index = 0
        self.drone.move_to((-50, -50)); self.lcd.update_status("SCAN COMPLETE")
        self.traversal_result_data = self.pending_report_data; self.pending_report_data = None
    def handle_events(self, event):
        if self.show_traversal_menu:
            self.menu_btn_in.handle_event(event); self.menu_btn_pre.handle_event(event); self.menu_btn_post.handle_event(event)
            if event.type == pygame.MOUSEBUTTONDOWN and not (self.menu_btn_in.is_hovered or self.menu_btn_pre.is_hovered or self.menu_btn_post.is_hovered):
                self.show_traversal_menu = False
            return
        if self.traversal_result_data and not self.is_traversing:
            if event.type == pygame.MOUSEBUTTONDOWN:
                self.traversal_result_data = None; self.lcd.update_status("READY")
            return
        self.lcd.handle_event(event); self.btn_insert.handle_event(event)
        self.btn_reset.handle_event(event); self.btn_scan.handle_event(event)
    def update(self):
        if self.show_traversal_menu: return
        self.belt_offset = (self.belt_offset + 1) % 20
        if self.highlight_timer > 0:
            self.highlight_timer -= 1
            if self.highlight_timer == 0: self.highlighted_node = None
        depth = self.logic.current_depth
        slot_width = self.SIM_WIDTH / max(1, 2 ** depth)
        target_node_size = int(slot_width * 0.50)
        if target_node_size > 80: target_node_size = 80
        if target_node_size < 20: target_node_size = 20
        size_diff = target_node_size - self.current_node_size
        if abs(size_diff) > 0.1: self.current_node_size += size_diff * 0.1
        else: self.current_node_size = target_node_size
        initial_spread = self.SIM_WIDTH / 2
        self._recalculate_layout(self.logic.root, self.ROOT_X, self.TOP_MARGIN, 0, initial_spread)
        self._update_node_positions(self.logic.root)
        current_pkg_size = self.current_node_size * 0.8
        for pkg in self.packages_group:
            pkg.resize(current_pkg_size)
        self.drone.resize(self.current_node_size * 0.8)
        self.packages_group.update()
        self.drone_group.update()
        self.lcd.update()
    def draw_traversal_menu(self):
        overlay = pygame.Surface((self.SIM_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        font_title = pygame.font.SysFont("Impact", 30)
        title_surf = font_title.render("SELECT TRAVERSAL METHOD", True, WHITE)
        self.screen.blit(title_surf, (self.SIM_WIDTH//2 - title_surf.get_width()//2, 180))
        self.menu_btn_in.draw(self.screen); self.menu_btn_pre.draw(self.screen); self.menu_btn_post.draw(self.screen)
    def draw_traversal_result(self):
        overlay = pygame.Surface((self.SIM_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        w, h = 500, 220; x, y = (self.SIM_WIDTH - w) // 2, (SCREEN_HEIGHT - h) // 2
        pygame.draw.rect(self.screen, (0,0,0,80), (x+5, y+5, w, h), border_radius=3)
        pygame.draw.rect(self.screen, (230, 230, 220), (x, y, w, h), border_radius=3)
        pygame.draw.rect(self.screen, (100,100,100), (x,y,w,h), 1, border_radius=3)
        font_header = pygame.font.SysFont("Courier New", 18, bold=True)
        header_surf = font_header.render(self.traversal_result_data["title"], True, (30,30,30))
        self.screen.blit(header_surf, (x + w//2 - header_surf.get_width()//2, y + 20))
        pygame.draw.line(self.screen, (180,180,170), (x+20, y+50), (x+w-20, y+50), 1)
        font_result = pygame.font.SysFont("Consolas", 24, bold=True)
        words = self.traversal_result_data["path"].split(' ')
        lines = []; current_line = ""
        for word in words:
            test_line = current_line + word + " "
            if font_result.size(test_line)[0] < w - 40:
                current_line = test_line
            else:
                lines.append(current_line); current_line = word + " "
        lines.append(current_line)
        line_y = y + 80
        for line in lines:
            result_surf = font_result.render(line, True, (20, 20, 20))
            self.screen.blit(result_surf, (x + 20, line_y)); line_y += 30
        if not self.is_traversing:
            font_prompt = pygame.font.SysFont("Arial", 12)
            prompt_surf = font_prompt.render("Click anywhere to dismiss", True, (100, 100, 100))
            self.screen.blit(prompt_surf, (x + w - prompt_surf.get_width() - 10, y + h - prompt_surf.get_height() - 10))
    def draw(self):
        self.screen.blit(self.bg_surface, (0, 0))
        self.draw_tree_nodes_and_labels(self.logic.root)
        self.packages_group.draw(self.screen)
        for pkg in self.packages_group:
            font_size = max(12, int(pkg.current_size * 0.5))
            font = pygame.font.SysFont("Arial", font_size, bold=True)
            shadow = font.render(str(pkg.value), True, (0,0,0,100))
            self.screen.blit(shadow, (pkg.rect.centerx - shadow.get_width()//2 + 1, pkg.rect.centery - shadow.get_height()//2 + 1))
            label = font.render(str(pkg.value), True, (255, 255, 255))
            self.screen.blit(label, (pkg.rect.centerx - label.get_width()//2, pkg.rect.centery - label.get_height()//2))
        self.drone_group.draw(self.screen)
        self.chassis.draw(self.screen); self.lcd.draw(self.screen)
        self.btn_insert.draw(self.screen); self.btn_reset.draw(self.screen); self.btn_scan.draw(self.screen)
        if self.show_traversal_menu: self.draw_traversal_menu()
        elif self.traversal_result_data: self.draw_traversal_result()
</file>

<file path="Full_Stack_Sim/simulation/site_sorting_floor.py/site_sorting_floor.py">
import pygame
import random
import math
from settings import *
from core.ui import HandheldChassis, LCDDisplay, RoundButton, Button
class SortingManager:
    def __init__(self):
        self.items = []
        self.original_items = []
    def generate_new_list(self, size=20):
        self.size = size
        self.items = random.sample(range(10, 100), self.size)
        self.original_items = list(self.items)
    def reset_to_original(self):
        if self.original_items:
            self.items = list(self.original_items)
    def get_bubble_sort_steps(self):
        steps = []
        items = list(self.items)
        n = len(items)
        for i in range(n):
            swapped = False
            for j in range(0, n - i - 1):
                steps.append({"type": "compare", "indices": (j, j + 1)})
                if items[j] > items[j + 1]:
                    items[j], items[j + 1] = items[j + 1], items[j]
                    swapped = True
                    steps.append({"type": "swap", "indices": (j, j + 1)})
            steps.append({"type": "lock", "index": n - 1 - i})
            if not swapped:
                for k in range(0, n - i - 1):
                    steps.append({"type": "lock", "index": k})
                break
        return steps
    def get_selection_sort_steps(self):
        steps = []
        items = list(self.items)
        n = len(items)
        for i in range(n):
            min_idx = i
            steps.append({"type": "highlight", "indices": [i]})
            for j in range(i + 1, n):
                steps.append({"type": "compare", "indices": (min_idx, j)})
                if items[j] < items[min_idx]:
                    min_idx = j
                    steps.append({"type": "highlight", "indices": [min_idx]})
            if min_idx != i:
                items[i], items[min_idx] = items[min_idx], items[i]
                steps.append({"type": "swap", "indices": (i, min_idx)})
            steps.append({"type": "lock", "index": i})
        return steps
    def get_insertion_sort_steps(self):
        steps = []
        items = list(self.items)
        n = len(items)
        if n > 0:
            steps.append({"type": "lock", "index": 0})
        for i in range(1, n):
            key = items[i]
            j = i - 1
            steps.append({"type": "highlight", "indices": [i]})
            while j >= 0 and key < items[j]:
                steps.append({"type": "compare", "indices": (j, i if j == i-1 else j+1)})
                items[j + 1] = items[j]
                steps.append({"type": "swap", "indices": (j, j + 1)})
                j -= 1
            items[j + 1] = key
            steps.append({"type": "lock", "index": i})
        steps.append({"type": "lock_all"})
        return steps
    def get_merge_sort_steps(self):
        steps = []
        items = list(self.items)
        def merge_sort_recursive(arr, start, end):
            if start < end:
                mid = (start + end) // 2
                merge_sort_recursive(arr, start, mid)
                merge_sort_recursive(arr, mid + 1, end)
                steps.append({"type": "highlight", "indices": list(range(start, end + 1))})
                left = arr[start:mid+1]
                right = arr[mid+1:end+1]
                i = j = 0; k = start
                while i < len(left) and j < len(right):
                    if left[i] <= right[j]: arr[k] = left[i]; i += 1
                    else: arr[k] = right[j]; j += 1
                    k += 1
                while i < len(left): arr[k] = left[i]; i += 1; k += 1
                while j < len(right): arr[k] = right[j]; j += 1; k += 1
                new_order_slice = arr[start:end+1]
                steps.append({"type": "reorder", "indices": list(range(start, end + 1)), "values": new_order_slice})
        merge_sort_recursive(items, 0, len(items) - 1)
        steps.append({"type": "lock_all"})
        return steps
    def get_quick_sort_steps(self):
        steps = []
        items = list(self.items)
        def partition(arr, low, high):
            pivot = arr[high]; i = low - 1
            steps.append({"type": "set_pivot", "index": high})
            for j in range(low, high):
                steps.append({"type": "compare", "indices": (j, high)})
                if arr[j] < pivot:
                    i += 1
                    arr[i], arr[j] = arr[j], arr[i]
                    if i != j: steps.append({"type": "swap", "indices": (i, j)})
            arr[i + 1], arr[high] = arr[high], arr[i + 1]
            if (i + 1) != high: steps.append({"type": "swap", "indices": (i + 1, high)})
            steps.append({"type": "lock", "index": i + 1})
            return i + 1
        def quick_sort_recursive(arr, low, high):
            if low < high:
                pi = partition(arr, low, high)
                quick_sort_recursive(arr, low, pi - 1)
                quick_sort_recursive(arr, pi + 1, high)
        quick_sort_recursive(items, 0, len(items) - 1)
        steps.append({"type": "lock_all"})
        return steps
class ContainerSprite(pygame.sprite.Sprite):
    def __init__(self, value, x, y, container_width, max_value):
        super().__init__()
        self.value = value
        self.pos_x, self.pos_y = float(x), float(y)
        self.target_x, self.target_y = float(x), float(y)
        self.is_moving = False
        self.on_finish_callback = None
        self.state = 'idle'
        self.width = int(container_width)
        self.height = int((value / max_value) * 200) + 50
        self.color_palette = [CONTAINER_BLUE, CONTAINER_RED, (180, 120, 40), (80, 80, 80)]
        self.base_color = random.choice(self.color_palette)
        self.image = self._create_surface()
        self.rect = self.image.get_rect(bottomleft=(x, y))
    def _create_surface(self):
        glow_padding = 15
        surf = pygame.Surface((self.width + glow_padding * 2, self.height + glow_padding * 2), pygame.SRCALPHA)
        self.container_body_rect = pygame.Rect(glow_padding, glow_padding, self.width, self.height)
        glow_color_map = {'comparing': (255, 80, 80), 'highlight': (255, 255, 100), 'pivot': (220, 100, 255)}
        if self.state in glow_color_map:
            glow_color = glow_color_map[self.state]
            for i in range(glow_padding // 2, 0, -1):
                glow_rect = self.container_body_rect.inflate(i * 2, i * 2)
                alpha = 120 - (i * 10)
                pygame.draw.rect(surf, (*glow_color, alpha), glow_rect, border_radius=i * 2)
        if self.state == 'sorted':
            main_color = CONTAINER_GREEN
            dark_color = (main_color[0] * 0.7, main_color[1] * 0.7, main_color[2] * 0.7)
        else:
            main_color = self.base_color
            dark_color = (main_color[0] * 0.7, main_color[1] * 0.7, main_color[2] * 0.7)
        pygame.draw.rect(surf, main_color, self.container_body_rect)
        for i in range(0, self.width, 6):
            pygame.draw.line(surf, dark_color, (self.container_body_rect.left + i, self.container_body_rect.top), (self.container_body_rect.left + i, self.container_body_rect.bottom), 1)
        pygame.draw.line(surf, (255,255,255,60), self.container_body_rect.topleft, self.container_body_rect.topright, 2)
        pygame.draw.rect(surf, (20, 20, 20), self.container_body_rect, 2)
        return surf
    def set_state(self, new_state):
        if self.state != new_state:
            self.state = new_state
            self.image = self._create_surface()
    def move_to(self, target_pos, callback=None):
        self.target_x, self.target_y = target_pos
        self.is_moving = True
        self.on_finish_callback = callback
    def update(self, speed_multiplier=1.0):
        if not self.is_moving: return
        dx = self.target_x - self.pos_x
        dy = self.target_y - self.pos_y
        effective_lerp = LERP_FACTOR * speed_multiplier
        effective_speed = MIN_SPEED * speed_multiplier
        if (dx**2 + dy**2) < effective_speed**2:
            self.pos_x, self.pos_y = self.target_x, self.target_y
            self.is_moving = False
            if self.on_finish_callback:
                cb = self.on_finish_callback
                self.on_finish_callback = None
                cb()
        else:
            self.pos_x += dx * effective_lerp
            self.pos_y += dy * effective_lerp
        self.rect.bottomleft = (int(self.pos_x), int(self.pos_y))
class GantryCraneSprite(pygame.sprite.Sprite):
    def __init__(self, y_pos, rail_width):
        super().__init__()
        self.y_pos = y_pos
        self.rail_width = rail_width
        self.pos_x = rail_width / 2
        self.target_x = self.pos_x
        self.is_moving = False
        self.on_finish_callback = None
        self.image = self._create_surface()
        self.rect = self.image.get_rect(center=(self.pos_x, self.y_pos))
    def _create_surface(self):
        surf = pygame.Surface((120, 150), pygame.SRCALPHA)
        center_x = surf.get_width() // 2
        pygame.draw.line(surf, (30,30,30), (center_x - 15, 0), (center_x - 15, 100), 2)
        pygame.draw.line(surf, (30,30,30), (center_x + 15, 0), (center_x + 15, 100), 2)
        hoist_body = pygame.Rect(center_x - 30, 100, 60, 20)
        pygame.draw.rect(surf, (80, 85, 90), hoist_body)
        pygame.draw.rect(surf, (50, 55, 60), hoist_body, 2)
        pygame.draw.rect(surf, (60, 65, 70), (center_x - 25, 120, 50, 10))
        pygame.draw.polygon(surf, STRIPE_YELLOW, [(center_x - 25, 130), (center_x - 15, 140), (center_x - 5, 130)])
        pygame.draw.polygon(surf, STRIPE_YELLOW, [(center_x + 25, 130), (center_x + 15, 140), (center_x + 5, 130)])
        trolley_rect = pygame.Rect(0, 0, 120, 30)
        pygame.draw.rect(surf, (60, 65, 70), trolley_rect, border_radius=3)
        pygame.draw.rect(surf, (90, 95, 100), trolley_rect, 2, border_radius=3)
        pygame.draw.circle(surf, (40,40,40), (15, 15), 5)
        pygame.draw.circle(surf, (40,40,40), (105, 15), 5)
        return surf
    def move_to(self, target_x, callback=None):
        self.target_x = target_x
        self.is_moving = True
        self.on_finish_callback = callback
    def update(self, speed_multiplier=1.0):
        if not self.is_moving: return
        dx = self.target_x - self.pos_x
        effective_lerp = LERP_FACTOR * speed_multiplier
        effective_speed = MIN_SPEED * speed_multiplier
        if abs(dx) < effective_speed:
            self.pos_x = self.target_x
            self.is_moving = False
            if self.on_finish_callback:
                cb = self.on_finish_callback; self.on_finish_callback = None; cb()
        else:
            self.pos_x += dx * effective_lerp
        self.rect.centerx = int(self.pos_x)
class SortingSimulation:
    def __init__(self, screen):
        self.screen = screen
        self.logic = SortingManager()
        self.SIM_WIDTH = 750
        self.FLOOR_Y = SCREEN_HEIGHT - 80
        self.STAGING_Y = self.FLOOR_Y - 350
        self.all_sprites = pygame.sprite.Group()
        self.containers = pygame.sprite.Group()
        self.crane_group = pygame.sprite.Group()
        self.ui_x = 750
        self.ui_w = 250
        self.chassis = HandheldChassis(self.ui_x + 10, 20, self.ui_w - 20, SCREEN_HEIGHT - 40)
        self.lcd = LCDDisplay(self.ui_x + 35, 80, self.ui_w - 70, 100)
        self.lcd.update_status("SORTING FLOOR")
        btn_cx = self.ui_x + self.ui_w // 2
        self.btn_load = RoundButton(btn_cx, 280, 45, BTN_BLUE_BASE, BTN_BLUE_LIGHT, "LOAD", self.action_load_containers)
        self.btn_sort = RoundButton(btn_cx, 390, 45, BTN_GREEN_BASE, BTN_GREEN_LIGHT, "SORT", self.action_open_sort_menu)
        self.btn_reset = RoundButton(btn_cx, 500, 45, BTN_RED_BASE, BTN_RED_LIGHT, "RESET", self.action_reset)
        self.speed_levels = [0.5, 1.0, 2.0, 4.0, 8.0]
        self.speed_index = 1
        self.speed_multiplier = self.speed_levels[self.speed_index]
        speed_btn_y = self.chassis.rect.bottom - 60
        speed_btn_w = 80
        speed_btn_h = 30
        self.btn_speed_down = Button(btn_cx - speed_btn_w - 5, speed_btn_y, speed_btn_w, speed_btn_h, "Speed -", self.decrease_speed)
        self.btn_speed_up = Button(btn_cx + 5, speed_btn_y, speed_btn_w, speed_btn_h, "Speed +", self.increase_speed)
        self.is_sorting = False
        self.sort_steps = []
        self.visual_containers = []
        self.slot_positions = []
        self.gantry_crane = GantryCraneSprite(y_pos=180, rail_width=self.SIM_WIDTH)
        self.crane_group.add(self.gantry_crane)
        self.all_sprites.add(self.gantry_crane)
        self.background = self._generate_static_background()
        self.show_sort_menu = False
        self._init_sort_menu()
        self.action_load_containers()
    def _init_sort_menu(self):
        menu_btn_w, menu_btn_h = 220, 40
        menu_cx = self.SIM_WIDTH // 2
        start_y = 200
        self.menu_btn_bubble = Button(menu_cx - menu_btn_w//2, start_y, menu_btn_w, menu_btn_h, "Bubble Sort", lambda: self.action_begin_sort("bubble"))
        self.menu_btn_selection = Button(menu_cx - menu_btn_w//2, start_y + 50, menu_btn_w, menu_btn_h, "Selection Sort", lambda: self.action_begin_sort("selection"))
        self.menu_btn_insertion = Button(menu_cx - menu_btn_w//2, start_y + 100, menu_btn_w, menu_btn_h, "Insertion Sort", lambda: self.action_begin_sort("insertion"))
        self.menu_btn_merge = Button(menu_cx - menu_btn_w//2, start_y + 150, menu_btn_w, menu_btn_h, "Merge Sort", lambda: self.action_begin_sort("merge"))
        self.menu_btn_quick = Button(menu_cx - menu_btn_w//2, start_y + 200, menu_btn_w, menu_btn_h, "Quick Sort", lambda: self.action_begin_sort("quick"))
        self.sort_menu_buttons = [self.menu_btn_bubble, self.menu_btn_selection, self.menu_btn_insertion, self.menu_btn_merge, self.menu_btn_quick]
    def _generate_static_background(self):
        bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        for y in range(self.FLOOR_Y):
            ratio = y / self.FLOOR_Y
            c = (int(20 + 20*ratio), int(25 + 20*ratio), int(30 + 20*ratio))
            pygame.draw.line(bg, c, (0, y), (SCREEN_WIDTH, y))
        for y in range(100, self.FLOOR_Y - 100, 80):
            pygame.draw.rect(bg, (40, 45, 50), (0, y, SCREEN_WIDTH, 15))
            pygame.draw.line(bg, (60, 65, 70), (0, y), (SCREEN_WIDTH, y), 1)
            pygame.draw.line(bg, (20, 25, 30), (0, y+15), (SCREEN_WIDTH, y+15), 1)
            for x in range(50, SCREEN_WIDTH, 200):
                pygame.draw.rect(bg, (50, 55, 60), (x, y-5, 20, 25))
                pygame.draw.rect(bg, (30, 35, 40), (x, y-5, 20, 25), 1)
        for i in range(int(SCREEN_WIDTH / 200) + 1):
            x = i * 200
            pygame.draw.rect(bg, (15, 18, 20), (x, 0, 40, self.FLOOR_Y))
            pygame.draw.rect(bg, (40, 45, 50), (x+5, 0, 30, self.FLOOR_Y))
            for ry in range(20, self.FLOOR_Y, 40):
                pygame.draw.circle(bg, (20, 25, 30), (x+10, ry), 3)
                pygame.draw.circle(bg, (20, 25, 30), (x+30, ry), 3)
            pygame.draw.rect(bg, (25, 30, 35), (x-5, self.FLOOR_Y - 20, 50, 20))
        rail_y = self.gantry_crane.y_pos - 30
        pygame.draw.rect(bg, (20, 22, 25), (0, rail_y - 20, SCREEN_WIDTH, 60))
        for x in range(0, SCREEN_WIDTH, 40):
            pygame.draw.line(bg, (50, 55, 60), (x, rail_y - 20), (x+20, rail_y + 40), 2)
            pygame.draw.line(bg, (50, 55, 60), (x+20, rail_y - 20), (x, rail_y + 40), 2)
        pygame.draw.rect(bg, (60, 65, 70), (0, rail_y - 20, SCREEN_WIDTH, 5))
        pygame.draw.rect(bg, (60, 65, 70), (0, rail_y + 35, SCREEN_WIDTH, 5))
        floor_rect = pygame.Rect(0, self.FLOOR_Y, SCREEN_WIDTH, SCREEN_HEIGHT - self.FLOOR_Y)
        bg.fill((35, 38, 40), floor_rect)
        for _ in range(10000):
            c = random.choice([(45, 48, 50), (25, 28, 30)])
            bg.set_at((random.randint(0, SCREEN_WIDTH - 1), random.randint(self.FLOOR_Y, SCREEN_HEIGHT - 1)), c)
        shadow_surf = pygame.Surface((SCREEN_WIDTH, 20), pygame.SRCALPHA)
        pygame.draw.rect(shadow_surf, (0,0,0,100), (0,0,SCREEN_WIDTH, 20))
        bg.blit(shadow_surf, (0, self.FLOOR_Y))
        zone_rect = pygame.Rect(20, self.FLOOR_Y + 10, self.SIM_WIDTH - 40, 100)
        pygame.draw.rect(bg, (30, 30, 30), zone_rect, border_radius=5)
        pygame.draw.rect(bg, (60, 60, 60), zone_rect, 2, border_radius=5)
        for i in range(zone_rect.left, zone_rect.right, 40):
            p1 = (i, zone_rect.bottom)
            p2 = (i + 20, zone_rect.bottom)
            p3 = (i + 30, zone_rect.bottom + 10)
            p4 = (i + 10, zone_rect.bottom + 10)
            pygame.draw.polygon(bg, STRIPE_YELLOW, [p1, p2, p3, p4])
        light_layer = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        light_layer.fill((0, 0, 0, 60))
        for i in range(100, self.SIM_WIDTH, 200):
            lx, ly = i, rail_y + 40
            cone_color = (200, 220, 255)
            points = [
                (lx - 20, ly), (lx + 20, ly),
                (lx + 120, self.FLOOR_Y + 50), (lx - 120, self.FLOOR_Y + 50)
            ]
            pygame.draw.polygon(light_layer, (*cone_color, 10), points)
            points_core = [
                (lx - 5, ly), (lx + 5, ly),
                (lx + 60, self.FLOOR_Y + 50), (lx - 60, self.FLOOR_Y + 50)
            ]
            pygame.draw.polygon(light_layer, (*cone_color, 20), points_core)
            spot_rect = pygame.Rect(lx - 80, self.FLOOR_Y - 20, 160, 40)
            pygame.draw.ellipse(light_layer, (*cone_color, 30), spot_rect)
            pygame.draw.rect(bg, (20, 20, 20), (lx - 15, ly - 5, 30, 10))
            pygame.draw.ellipse(bg, (220, 255, 255), (lx - 10, ly, 20, 6))
        bg.blit(light_layer, (0,0))
        return bg
    def _rebuild_visuals(self):
        for c in self.containers:
            c.kill()
        self.visual_containers.clear()
        self.slot_positions.clear()
        container_width = (self.SIM_WIDTH - 100) / self.logic.size
        start_x = 50
        for i, value in enumerate(self.logic.items):
            x = start_x + (i * container_width)
            self.slot_positions.append(x)
            c = ContainerSprite(value, x, self.FLOOR_Y, container_width - 4, 100)
            self.containers.add(c)
            self.all_sprites.add(c)
            self.visual_containers.append(c)
    def action_load_containers(self):
        if self.is_sorting: return
        size_text = self.lcd.text if self.lcd.text else "20"
        try:
            size = int(size_text)
            if not 10 <= size <= 30:
                self.lcd.update_status("ERR: SIZE 10-30")
                return
        except ValueError:
            self.lcd.update_status("ERR: NOT A NUMBER")
            return
        self.lcd.update_status("LOADING CARGO...")
        self.logic.generate_new_list(size=size)
        self._rebuild_visuals()
        self.lcd.update_status("READY TO SORT")
    def action_open_sort_menu(self):
        if self.is_sorting or not self.visual_containers: return
        self.show_sort_menu = True
    def action_begin_sort(self, sort_type):
        self.show_sort_menu = False
        if self.is_sorting: return
        self.logic.reset_to_original()
        self._rebuild_visuals()
        self.is_sorting = True
        self.lcd.update_status(f"SORTING: {sort_type.upper()}")
        st_map = {
            "bubble": self.logic.get_bubble_sort_steps,
            "selection": self.logic.get_selection_sort_steps,
            "insertion": self.logic.get_insertion_sort_steps,
            "merge": self.logic.get_merge_sort_steps,
            "quick": self.logic.get_quick_sort_steps
        }
        self.sort_steps = st_map[sort_type]()
        self.process_next_step()
    def action_reset(self):
        for sprite in self.all_sprites:
            sprite.is_moving = False
            sprite.on_finish_callback = None
        self.is_sorting = False
        self.sort_steps.clear()
        self.show_sort_menu = False
        self.lcd.update_status("SYSTEM RESET")
        self.action_load_containers()
    def increase_speed(self):
        if self.speed_index < len(self.speed_levels) - 1:
            self.speed_index += 1
            self.speed_multiplier = self.speed_levels[self.speed_index]
            self.lcd.update_status(f"SPEED: {self.speed_multiplier}x")
    def decrease_speed(self):
        if self.speed_index > 0:
            self.speed_index -= 1
            self.speed_multiplier = self.speed_levels[self.speed_index]
            self.lcd.update_status(f"SPEED: {self.speed_multiplier}x")
    def reset_container_states(self):
        for c in self.visual_containers:
            if c.state != 'sorted':
                c.set_state('idle')
    def on_reorder_complete(self, indices, values):
        value_map = {c.value: c for c in self.visual_containers}
        reordered_visual_slice = [value_map[v] for v in values]
        start, end = indices[0], indices[-1]
        self.visual_containers[start : end + 1] = reordered_visual_slice
        self.process_next_step()
    def process_next_step(self):
        if not self.sort_steps or not self.is_sorting:
            self.is_sorting = False
            self.lcd.update_status("SORT COMPLETE")
            self.reset_container_states()
            return
        step = self.sort_steps.pop(0)
        self.reset_container_states()
        step_type = step.get("type")
        if step_type == "compare":
            idx1, idx2 = step["indices"]
            c1 = self.visual_containers[idx1]
            c2 = self.visual_containers[idx2]
            c1.set_state('comparing')
            c2.set_state('comparing')
            target_crane_x = (c1.rect.centerx + c2.rect.centerx) / 2
            self.gantry_crane.move_to(target_crane_x, self.process_next_step)
        elif step_type == "swap":
            idx1, idx2 = step["indices"]
            c1 = self.visual_containers[idx1]
            c2 = self.visual_containers[idx2]
            self.visual_containers[idx1], self.visual_containers[idx2] = c2, c1
            pos1_x = self.slot_positions[idx1]
            pos2_x = self.slot_positions[idx2]
            c1.move_to((pos2_x, c1.pos_y))
            c2.move_to((pos1_x, c2.pos_y), self.process_next_step)
        elif step_type in ["lock", "set_pivot", "highlight"]:
            state = {
                "lock": "sorted",
                "set_pivot": "pivot",
                "highlight": "highlight"
            }[step_type]
            indices = step.get("indices", [step.get("index")])
            for idx in indices:
                if 0 <= idx < len(self.visual_containers):
                    self.visual_containers[idx].set_state(state)
            self.process_next_step()
        elif step_type == "reorder":
            indices = step["indices"]
            values = step["values"]
            value_map = {c.value: c for c in self.visual_containers}
            callback = lambda: self.on_reorder_complete(indices, values)
            for i, idx in enumerate(indices):
                cb = callback if i == len(indices) - 1 else None
                target_x = self.slot_positions[idx]
                sprite_to_move = value_map[values[i]]
                sprite_to_move.move_to((target_x, self.FLOOR_Y), cb)
        elif step_type == "lock_all":
            for c in self.visual_containers:
                c.set_state('sorted')
            self.process_next_step()
    def handle_events(self, event):
        if self.show_sort_menu:
            for btn in self.sort_menu_buttons:
                btn.handle_event(event)
            if event.type == pygame.MOUSEBUTTONDOWN:
                if not any(btn.rect.collidepoint(event.pos) for btn in self.sort_menu_buttons):
                    self.show_sort_menu = False
            return
        self.lcd.handle_event(event)
        self.btn_reset.handle_event(event)
        self.btn_speed_up.handle_event(event)
        self.btn_speed_down.handle_event(event)
        if not self.is_sorting:
            self.btn_load.handle_event(event)
            self.btn_sort.handle_event(event)
    def update(self):
        if self.show_sort_menu: return
        self.all_sprites.update(self.speed_multiplier)
        self.lcd.update()
    def draw_sort_menu(self):
        overlay = pygame.Surface((self.SIM_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        font_title = pygame.font.SysFont("Impact", 30)
        title_surf = font_title.render("SELECT SORTING ALGORITHM", True, WHITE)
        self.screen.blit(title_surf, (self.SIM_WIDTH//2 - title_surf.get_width()//2, 140))
        for btn in self.sort_menu_buttons:
            btn.draw(self.screen)
    def draw(self):
        self.screen.blit(self.background, (0, 0))
        self.all_sprites.draw(self.screen)
        font = pygame.font.SysFont("Arial", 10, bold=True)
        for container in self.containers:
            text_surf = font.render(str(container.value), True, BLACK)
            padding = 3
            label_size = (text_surf.get_width() + padding * 2, text_surf.get_height() + padding * 2)
            label_surf = pygame.Surface(label_size)
            label_surf.fill(WHITE)
            pygame.draw.rect(label_surf, BLACK, label_surf.get_rect(), 1)
            label_surf.blit(text_surf, (padding, padding))
            visible_body_rect = pygame.Rect(
                container.rect.left + container.container_body_rect.left,
                container.rect.top + container.container_body_rect.top,
                container.container_body_rect.width,
                container.container_body_rect.height
            )
            label_rect = label_surf.get_rect(midbottom=visible_body_rect.midtop, y=visible_body_rect.top - 15)
            self.screen.blit(label_surf, label_rect)
        self.chassis.draw(self.screen)
        self.lcd.draw(self.screen)
        self.btn_load.draw(self.screen)
        self.btn_sort.draw(self.screen)
        self.btn_reset.draw(self.screen)
        self.btn_speed_up.draw(self.screen)
        self.btn_speed_down.draw(self.screen)
        if self.show_sort_menu:
            self.draw_sort_menu()
</file>

<file path="Full_Stack_Sim/simulation/site_warehouse_array.py/site_warehouse_array.py">
import pygame
import random
import math
from settings import *
from core.ui import HandheldChassis, LCDDisplay, RoundButton, Button
class ArrayManager:
    def __init__(self, capacity=10):
        self.resize(capacity)
    def resize(self, capacity):
        self.capacity = capacity
        self.data = [None] * capacity
    def write(self, index, value):
        if index < 0 or index >= self.capacity: return {"type": "ERROR", "message": "INDEX OOB"}
        old_value = self.data[index]
        self.data[index] = value
        return {"type": "WRITE", "index": index, "value": value, "replaced": old_value is not None}
    def read(self, index):
        if index < 0 or index >= self.capacity: return {"type": "ERROR", "message": "INDEX OOB"}
        value = self.data[index]
        if value is None: return {"type": "EMPTY", "index": index, "message": "SLOT EMPTY"}
        return {"type": "READ", "index": index, "value": value}
    def clear_slot(self, index):
        if index < 0 or index >= self.capacity: return {"type": "ERROR", "message": "INDEX OOB"}
        if self.data[index] is None: return {"type": "ERROR", "message": "ALREADY EMPTY"}
        value = self.data[index]
        self.data[index] = None
        return {"type": "CLEAR", "index": index, "value": value}
    def get_manifest(self):
        return [{"index": i, "value": v} for i, v in enumerate(self.data)]
class PalletCrateSprite(pygame.sprite.Sprite):
    def __init__(self, x, y, value):
        super().__init__()
        self.value = str(value)
        self.width = 40
        self.height = 40
        self.image = self._create_surface()
        self.rect = self.image.get_rect(midbottom=(x, y))
    def _create_surface(self):
        surf = pygame.Surface((self.width, self.height), pygame.SRCALPHA)
        pallet_h = 6
        box_h = self.height - pallet_h
        pallet_color = (139, 105, 70)
        dark_wood = (100, 70, 40)
        pygame.draw.rect(surf, pallet_color, (0, self.height-pallet_h, self.width, pallet_h))
        for i in range(0, self.width, 4):
            pygame.draw.line(surf, dark_wood, (i, self.height-pallet_h), (i, self.height), 1)
        pygame.draw.rect(surf, (20, 20, 20), (0, self.height - pallet_h//2 - 1, self.width, 2))
        pygame.draw.rect(surf, pallet_color, (0, self.height-pallet_h, 4, pallet_h))
        pygame.draw.rect(surf, pallet_color, (self.width//2-2, self.height-pallet_h, 4, pallet_h))
        pygame.draw.rect(surf, pallet_color, (self.width-4, self.height-pallet_h, 4, pallet_h))
        box_rect = pygame.Rect(2, 0, self.width-4, box_h)
        pygame.draw.rect(surf, BOX_COLOR_1, box_rect)
        pygame.draw.rect(surf, (160, 110, 60), box_rect, 1)
        for i in range(box_rect.left + 4, box_rect.right, 4):
            pygame.draw.line(surf, (190, 125, 60), (i, box_rect.top), (i, box_rect.bottom), 1)
        tape_y = int(box_h * 0.25)
        pygame.draw.line(surf, BOX_TAPE, (2, tape_y), (self.width-2, tape_y), 4)
        label_w = self.width * 0.8
        label_h = box_h * 0.4
        label_x = (self.width - label_w) // 2
        label_y = (box_h - label_h) // 2 + 5
        pygame.draw.rect(surf, (240, 240, 240), (label_x, label_y, label_w, label_h))
        font = pygame.font.SysFont("Arial", 12, bold=True)
        txt = font.render(self.value, True, (20, 20, 20))
        if txt.get_width() > label_w - 2:
            txt = pygame.transform.smoothscale(txt, (int(label_w - 2), txt.get_height()))
        surf.blit(txt, (self.width//2 - txt.get_width()//2, label_y + label_h//2 - txt.get_height()//2))
        pygame.draw.polygon(surf, (200, 50, 50), [
            (self.width - 8, 4), (self.width - 5, 8), (self.width - 11, 8)
        ])
        return surf
class ForkliftSprite(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.home_x, self.home_y = float(x), float(y)
        self.pos_x, self.pos_y = self.home_x, self.home_y
        self.target_x = self.home_x
        self.is_moving = False
        self.state = 'IDLE'
        self.callback = None
        self.cargo_sprite = None
        self.fork_height = 0
        self.max_fork_height = 180
        self.width = 70
        self.height = 50
        self.facing_right = True
        self.original_image_right = self._create_surface(facing_right=True)
        self.original_image_left = self._create_surface(facing_right=False)
        self.image = self.original_image_right
        self.rect = self.image.get_rect(bottomleft=(int(self.pos_x), int(self.pos_y)))
    def _create_surface(self, facing_right):
        surf = pygame.Surface((self.width + 50, self.height + self.max_fork_height + 20), pygame.SRCALPHA)
        floor_y = surf.get_height() - 10
        direction = 1 if facing_right else -1
        body_x_start = 0 if facing_right else 40
        tire_radius = 14
        rear_tire_x = body_x_start + 15 if facing_right else body_x_start + self.width - 15
        front_tire_x = body_x_start + self.width - 15 if facing_right else body_x_start + 15
        for tx in [rear_tire_x, front_tire_x]:
            pygame.draw.circle(surf, (20, 20, 20), (tx, floor_y), tire_radius)
            pygame.draw.circle(surf, (50, 50, 50), (tx, floor_y), 6)
            for i in range(0, 360, 45):
                rad = math.radians(i)
                ox = tx + math.cos(rad) * (tire_radius - 2)
                oy = floor_y + math.sin(rad) * (tire_radius - 2)
                pygame.draw.circle(surf, (40, 40, 40), (int(ox), int(oy)), 2)
        chassis_h = 35
        chassis_rect = pygame.Rect(body_x_start, floor_y - chassis_h, self.width, chassis_h - 5)
        pygame.draw.rect(surf, (255, 200, 0), chassis_rect, border_radius=6)
        pygame.draw.rect(surf, (200, 150, 0), chassis_rect, 2, border_radius=6)
        pygame.draw.rect(surf, (30, 30, 30), (body_x_start, floor_y - 15, self.width, 10))
        vent_x = body_x_start + 10 if facing_right else body_x_start + self.width - 25
        for i in range(3):
            pygame.draw.line(surf, (50, 50, 50), (vent_x + i*5, floor_y - 25), (vent_x + i*5, floor_y - 18), 2)
        cab_w = 35
        cab_h = 45
        cab_x = body_x_start + 10 if facing_right else body_x_start + self.width - 10 - cab_w
        cab_rect = pygame.Rect(cab_x, floor_y - chassis_h - cab_h + 5, cab_w, cab_h)
        pygame.draw.rect(surf, (40, 40, 45), cab_rect, 3, border_radius=2)
        pygame.draw.rect(surf, (40, 40, 45), (cab_x - 2, cab_rect.top, cab_w + 4, 4))
        seat_x = cab_x + 5 if facing_right else cab_x + cab_w - 15
        pygame.draw.rect(surf, (60, 60, 60), (seat_x, floor_y - chassis_h - 10, 10, 15))
        pygame.draw.circle(surf, (255, 100, 0), (cab_x + cab_w//2, cab_rect.top - 2), 3)
        mast_x = body_x_start + self.width if facing_right else body_x_start
        mast_w = 8
        mast_h = self.height + self.max_fork_height - 20
        mast_rect = pygame.Rect(mast_x - 4, floor_y - mast_h, mast_w, mast_h)
        pygame.draw.rect(surf, (60, 65, 70), mast_rect)
        pygame.draw.rect(surf, (30, 35, 40), mast_rect, 1)
        pygame.draw.rect(surf, (180, 180, 190), (mast_x - 2, floor_y - mast_h + 5, 4, mast_h - 10))
        fork_y = floor_y - 5 - self.fork_height
        fork_len = 35
        fork_start_x = mast_x if facing_right else mast_x - fork_len
        pygame.draw.rect(surf, (40, 40, 40), (mast_x - 5, fork_y - 25, 10, 30))
        pygame.draw.rect(surf, (150, 150, 155), (fork_start_x, fork_y, fork_len, 4))
        return surf
    def move_to(self, target_x, callback=None):
        self.target_x = target_x; self.callback = callback; self.is_moving = True
        if self.target_x > self.pos_x: self.facing_right = True
        elif self.target_x < self.pos_x: self.facing_right = False
        self.image = self.original_image_right if self.facing_right else self.original_image_left
    def lift_forks(self, height, callback=None):
        self.target_fork_height = height; self.callback = callback
        self.state = 'LIFTING' if height > self.fork_height else 'LOWERING'
    def update(self):
        if self.is_moving:
            dx = self.target_x - self.pos_x
            if abs(dx) < MIN_SPEED * 2:
                self.pos_x = self.target_x; self.is_moving = False
                if self.callback: cb = self.callback; self.callback = None; cb()
            else:
                self.pos_x += dx * 0.08
                if abs(dx) > 1 and abs(dx * 0.08) < 1: self.pos_x += 1 if dx > 0 else -1
        if self.state in ['LIFTING', 'LOWERING']:
            dh = self.target_fork_height - self.fork_height
            if abs(dh) < 1:
                self.fork_height = self.target_fork_height; self.state = 'IDLE'
                self.image = self._create_surface(self.facing_right)
                if self.callback: cb = self.callback; self.callback = None; cb()
            else:
                self.fork_height += dh * 0.2
                self.image = self._create_surface(self.facing_right)
        if self.cargo_sprite:
            mast_offset = self.width if self.facing_right else 0
            fork_x = self.pos_x + mast_offset
            if not self.facing_right: fork_x -= 35
            fork_y = self.pos_y - 10 - self.fork_height
            self.cargo_sprite.rect.bottom = int(fork_y)
            self.cargo_sprite.rect.centerx = int(fork_x + 17.5)
        self.rect = self.image.get_rect(bottomleft=(int(self.pos_x), int(self.pos_y)))
class ArraySimulation:
    def __init__(self, screen):
        self.screen = screen
        self.logic = ArrayManager(capacity=10)
        self.all_sprites = pygame.sprite.Group()
        self.crates_group = pygame.sprite.Group()
        self.SIM_WIDTH = 750
        self.FLOOR_Y = SCREEN_HEIGHT - 100
        self.RACK_BASE_Y = self.FLOOR_Y - 100
        self.RACK_X_START = 110
        self.SLOT_WIDTH = 60
        self.LEVEL_HEIGHT = 70
        self.HOME_X = 20
        self.forklift = ForkliftSprite(self.HOME_X, self.FLOOR_Y)
        self.all_sprites.add(self.forklift)
        self.ui_x = 750; self.ui_w = 250
        self.chassis = HandheldChassis(self.ui_x + 10, 20, self.ui_w - 20, SCREEN_HEIGHT - 40)
        self.lcd = LCDDisplay(self.ui_x + 35, 80, self.ui_w - 70, 100)
        self.lcd.update_status("SELECT A SLOT")
        btn_cx = self.ui_x + self.ui_w // 2
        self.btn_write = RoundButton(btn_cx, 260, 45, BTN_GREEN_BASE, BTN_GREEN_LIGHT, "WRITE", self.action_write)
        self.btn_manifest = RoundButton(btn_cx, 480, 45, BTN_BLUE_BASE, BTN_BLUE_LIGHT, "SUMMARY", self.action_manifest)
        self.btn_clear = RoundButton(btn_cx, 590, 45, BTN_RED_BASE, BTN_RED_LIGHT, "CLEAR", self.action_clear)
        self.btn_resize = RoundButton(btn_cx, 370, 45, (200, 180, 50), (255, 230, 80), "RESIZE", self.action_resize_click)
        self.selected_index = None
        self.hovered_index = None
        self.is_animating = False
        self.show_manifest = False
        self.manifest_scroll = 0
        self.scanner_active = False
        self.scanner_timer = 0
        self.input_mode = None
        self.recalculate_layout()
        self.bg_surface = self._generate_background()
    def recalculate_layout(self):
        self.slot_rects = []
        for i in range(self.logic.capacity):
            row = i // 10
            col = i % 10
            x = self.RACK_X_START + (col * self.SLOT_WIDTH)
            y = self.RACK_BASE_Y - (row * self.LEVEL_HEIGHT)
            rect = pygame.Rect(x, y - 50, self.SLOT_WIDTH, 60)
            self.slot_rects.append(rect)
    def _generate_background(self):
        bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        bg.fill(WALL_BASE_COLOR)
        floor_rect = pygame.Rect(0, self.FLOOR_Y, SCREEN_WIDTH, SCREEN_HEIGHT - self.FLOOR_Y)
        bg.fill(FLOOR_COLOR, floor_rect)
        for x in range(0, SCREEN_WIDTH, 20):
            color = (75, 80, 85) if (x // 20) % 2 == 0 else (85, 90, 95)
            pygame.draw.rect(bg, color, (x, 0, 20, self.FLOOR_Y))
        for _ in range(5000):
            color = random.choice([CONCRETE_NOISE_1, CONCRETE_NOISE_2])
            bg.set_at((random.randint(0, SCREEN_WIDTH-1), random.randint(self.FLOOR_Y, SCREEN_HEIGHT-1)), color)
        rack_zone_rect = pygame.Rect(self.RACK_X_START - 20, self.FLOOR_Y, (self.SLOT_WIDTH * 10) + 40, 40)
        pygame.draw.rect(bg, (40, 40, 40), rack_zone_rect)
        for i in range(0, rack_zone_rect.width, 30):
            p1 = (rack_zone_rect.left + i, rack_zone_rect.bottom)
            p2 = (rack_zone_rect.left + i + 15, rack_zone_rect.top)
            pygame.draw.line(bg, STRIPE_YELLOW, p1, p2, 3)
        pygame.draw.line(bg, (0,0,0), (0, self.FLOOR_Y), (SCREEN_WIDTH, self.FLOOR_Y), 3)
        num_rows = (self.logic.capacity - 1) // 10 + 1
        rack_w = self.SLOT_WIDTH * 10 + 20
        upright_color = (40, 60, 90)
        for i in range(11):
            x = self.RACK_X_START + (i * self.SLOT_WIDTH)
            top_y = self.RACK_BASE_Y - ((num_rows - 1) * self.LEVEL_HEIGHT) - 10
            pygame.draw.rect(bg, (30, 45, 70), (x+5, top_y, 4, self.FLOOR_Y - top_y))
            pygame.draw.rect(bg, upright_color, (x-2, top_y, 4, self.FLOOR_Y - top_y))
            pygame.draw.rect(bg, (30, 30, 30), (x-4, self.FLOOR_Y-2, 8, 2))
        beam_color = (220, 100, 40)
        beam_shadow = (180, 80, 30)
        for r in range(num_rows):
            y = self.RACK_BASE_Y - (r * self.LEVEL_HEIGHT)
            pygame.draw.rect(bg, beam_color, (self.RACK_X_START - 10, y, rack_w, 8))
            pygame.draw.rect(bg, beam_shadow, (self.RACK_X_START - 10, y+8, rack_w, 2))
            for c in range(10):
                idx = r * 10 + c
                if idx < self.logic.capacity:
                    x = self.RACK_X_START + (c * self.SLOT_WIDTH)
                    pygame.draw.rect(bg, (200, 200, 200), (x + self.SLOT_WIDTH//2 - 10, y + 12, 20, 14))
                    font = pygame.font.SysFont("Arial", 10, bold=True)
                    txt = font.render(str(idx), True, (20, 20, 20))
                    bg.blit(txt, (x + self.SLOT_WIDTH//2 - txt.get_width()//2, y + 13))
        light_layer = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        for i in range(0, SCREEN_WIDTH, 200):
            pygame.draw.rect(bg, (20, 20, 20), (i, 0, 60, 20))
            pygame.draw.ellipse(bg, (200, 255, 255), (i+5, 15, 50, 10))
            points = [(i+10, 20), (i+50, 20), (i+150, self.FLOOR_Y), (i-80, self.FLOOR_Y)]
            pygame.draw.polygon(light_layer, (255, 255, 220, 15), points)
        bg.blit(light_layer, (0,0))
        return bg
    def get_slot_pos(self, index):
        row = index // 10
        col = index % 10
        x = self.RACK_X_START + (col * self.SLOT_WIDTH) + (self.SLOT_WIDTH // 2)
        y = self.RACK_BASE_Y - (row * self.LEVEL_HEIGHT)
        return x, y
    def handle_mouse_click(self, pos):
        if self.is_animating: return
        for i, rect in enumerate(self.slot_rects):
            if rect.collidepoint(pos):
                self.selected_index = i
                self.input_mode = 'VALUE'
                self.lcd.update_status(f"SLOT {i} SELECTED")
                self.lcd.text = ""
                return
    def action_resize_click(self):
        if self.is_animating: return
        if self.input_mode == 'SIZE':
            self.execute_resize()
        else:
            self.input_mode = 'SIZE'
            self.selected_index = None
            self.lcd.update_status("ENTER SIZE [10-30]")
            self.lcd.text = ""
    def execute_resize(self):
        text = self.lcd.text
        if not text.isdigit():
            self.lcd.update_status("ERR: NUMBERS ONLY")
            return
        size = int(text)
        if not 10 <= size <= 30:
            self.lcd.update_status("ERR: 10-30 ONLY")
            return
        self.logic.resize(size)
        for c in self.crates_group: c.kill()
        self.recalculate_layout()
        self.bg_surface = self._generate_background()
        self.forklift.move_to(self.HOME_X)
        self.lcd.update_status(f"RESIZED TO {size}")
        self.input_mode = None
    def action_write(self):
        if self.is_animating: return
        if self.selected_index is None:
            self.lcd.update_status("ERR: SELECT SLOT")
            return
        text = self.lcd.text
        try:
            val = int(text)
        except ValueError:
            self.lcd.update_status("ERR: INTEGERS ONLY")
            return
        if val > 999 or val < -999:
            self.lcd.update_status("ERR: -999 TO 999")
            return
        receipt = self.logic.write(self.selected_index, val)
        self.is_animating = True
        self.lcd.update_status(f"WRITING {val}...")
        self.lcd.text = ""
        target_idx = self.selected_index
        self.selected_index = None
        self.input_mode = None
        existing_crate = next((c for c in self.crates_group if abs(c.rect.centerx - self.get_slot_pos(target_idx)[0]) < 10 and abs(c.rect.bottom - self.get_slot_pos(target_idx)[1]) < 10), None)
        if existing_crate:
            self.animate_removal(existing_crate, lambda: self.animate_insertion(target_idx, val))
        else:
            self.animate_insertion(target_idx, val)
    def action_manifest(self):
        if self.is_animating: return
        self.show_manifest = True
        self.manifest_scroll = 0
        self.selected_index = None
        self.input_mode = None
        self.lcd.update_status("MANIFEST OPEN")
    def action_clear(self):
        if self.is_animating: return
        if self.selected_index is None:
            self.lcd.update_status("ERR: SELECT SLOT")
            return
        receipt = self.logic.clear_slot(self.selected_index)
        target_idx = self.selected_index
        self.selected_index = None
        self.input_mode = None
        if receipt['type'] == 'ERROR':
            self.lcd.update_status(receipt['message'])
            return
        self.is_animating = True
        self.lcd.update_status("CLEARING SLOT...")
        target_crate = next((c for c in self.crates_group if abs(c.rect.centerx - self.get_slot_pos(target_idx)[0]) < 10 and abs(c.rect.bottom - self.get_slot_pos(target_idx)[1]) < 10), None)
        if target_crate:
            self.animate_removal(target_crate, self.on_animation_complete)
        else:
            self.on_animation_complete()
    def animate_insertion(self, index, value):
        crate = PalletCrateSprite(self.HOME_X, self.FLOOR_Y, value)
        self.all_sprites.add(crate); self.crates_group.add(crate)
        self.forklift.cargo_sprite = crate
        slot_x, slot_y = self.get_slot_pos(index)
        target_x = slot_x - 87
        shelf_lift = (self.FLOOR_Y - slot_y)
        clearance_lift = shelf_lift + 15
        def step5_return():
            self.forklift.move_to(self.HOME_X, self.on_animation_complete)
        def step4_lower_forks():
            self.forklift.lift_forks(0, step5_return)
        def step3_detach():
            self.forklift.cargo_sprite = None
            crate.rect.bottom = slot_y
            step4_lower_forks()
        def step2_lower_to_shelf():
            self.forklift.lift_forks(shelf_lift, step3_detach)
        def step1_move_in():
            self.forklift.move_to(target_x, step2_lower_to_shelf)
        def step0_lift():
            self.forklift.lift_forks(clearance_lift, step1_move_in)
        step0_lift()
    def animate_removal(self, crate, next_callback):
        target_x = crate.rect.centerx - 87
        slot_y = crate.rect.bottom
        shelf_lift = (self.FLOOR_Y - slot_y)
        clearance_lift = shelf_lift + 15
        def step5_destroy():
            crate.kill()
            self.forklift.cargo_sprite = None
            self.forklift.move_to(self.HOME_X, next_callback)
        def step4_lower_to_floor():
            self.forklift.lift_forks(0, step5_destroy)
        def step3_move_out():
            self.forklift.move_to(target_x - 20, step4_lower_to_floor)
        def step2_lift_off():
            self.forklift.cargo_sprite = crate
            self.forklift.lift_forks(clearance_lift, step3_move_out)
        def step1_raise_forks():
            self.forklift.lift_forks(shelf_lift, step2_lift_off)
        self.forklift.move_to(target_x, step1_raise_forks)
    def on_animation_complete(self):
        self.is_animating = False
        self.lcd.update_status("READY")
    def handle_events(self, event):
        if self.show_manifest:
            if event.type == pygame.MOUSEBUTTONDOWN and event.button in [1, 3]:
                self.show_manifest = False
                self.lcd.update_status("READY")
            elif event.type == pygame.MOUSEWHEEL:
                self.manifest_scroll += event.y * 20
                max_scroll = 0
                min_scroll = -max(0, (len(self.logic.data) * 20) - 350)
                if self.manifest_scroll > max_scroll: self.manifest_scroll = max_scroll
                if self.manifest_scroll < min_scroll: self.manifest_scroll = min_scroll
            return
        self.lcd.handle_event(event)
        self.btn_write.handle_event(event)
        self.btn_manifest.handle_event(event)
        self.btn_clear.handle_event(event)
        self.btn_resize.handle_event(event)
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            self.handle_mouse_click(event.pos)
    def update(self):
        if self.show_manifest: return
        self.all_sprites.update()
        self.lcd.update()
        self.hovered_index = None
        if not self.is_animating:
            m_pos = pygame.mouse.get_pos()
            for i, rect in enumerate(self.slot_rects):
                if rect.collidepoint(m_pos):
                    self.hovered_index = i
                    break
    def draw_manifest(self):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        w, h = 400, 500
        x, y = (SCREEN_WIDTH - w) // 2, (SCREEN_HEIGHT - h) // 2
        pygame.draw.rect(self.screen, (240, 240, 235), (x, y, w, h), border_radius=5)
        font_head = pygame.font.SysFont("Courier New", 24, bold=True)
        head = font_head.render("INVENTORY MANIFEST", True, (20, 20, 20))
        self.screen.blit(head, (x + w//2 - head.get_width()//2, y + 20))
        pygame.draw.line(self.screen, (50, 50, 50), (x+20, y+50), (x+w-20, y+50), 2)
        list_rect = pygame.Rect(x + 20, y + 60, w - 40, h - 100)
        self.screen.set_clip(list_rect)
        font_mono = pygame.font.SysFont("Courier New", 16)
        manifest = self.logic.get_manifest()
        col1_x = x + 40
        col2_x = x + 200
        self.screen.set_clip(None)
        pygame.draw.rect(self.screen, (240, 240, 235), (x+20, y+60, w-40, 30))
        self.screen.blit(font_mono.render("INDEX", True, (80, 80, 80)), (col1_x, y + 65))
        self.screen.blit(font_mono.render("VALUE", True, (80, 80, 80)), (col2_x, y + 65))
        pygame.draw.line(self.screen, (150, 150, 150), (x+20, y+85), (x+w-20, y+85), 1)
        content_rect = pygame.Rect(x + 20, y + 90, w - 40, h - 130)
        self.screen.set_clip(content_rect)
        start_y = y + 90 + self.manifest_scroll
        for item in manifest:
            idx_str = f"[{item['index']}]"
            val_str = str(item['value']) if item['value'] is not None else "---"
            color = (0, 0, 0) if item['value'] is not None else (150, 150, 150)
            self.screen.blit(font_mono.render(idx_str, True, (50, 50, 50)), (col1_x, start_y))
            self.screen.blit(font_mono.render(val_str, True, color), (col2_x, start_y))
            start_y += 20
        self.screen.set_clip(None)
        foot = font_mono.render("- CLICK TO CLOSE -", True, (100, 100, 100))
        self.screen.blit(foot, (x + w//2 - foot.get_width()//2, y + h - 30))
    def draw(self):
        self.screen.blit(self.bg_surface, (0, 0))
        if self.hovered_index is not None and self.hovered_index != self.selected_index:
            rect = self.slot_rects[self.hovered_index]
            pygame.draw.rect(self.screen, (255, 255, 255), rect, 2, border_radius=4)
        if self.selected_index is not None:
            rect = self.slot_rects[self.selected_index]
            pygame.draw.rect(self.screen, (0, 255, 0), rect, 2, border_radius=4)
            if self.logic.data[self.selected_index] is None and not self.is_animating:
                ghost_surf = pygame.Surface((40, 40), pygame.SRCALPHA)
                pygame.draw.rect(ghost_surf, (0, 255, 0, 50), (0, 0, 40, 40), border_radius=2)
                pygame.draw.rect(ghost_surf, (0, 255, 0), (0, 0, 40, 40), 1, border_radius=2)
                cx, cy = self.get_slot_pos(self.selected_index)
                self.screen.blit(ghost_surf, (cx - 20, cy - 40))
        for sprite in self.all_sprites:
            if isinstance(sprite, ForkliftSprite):
                s = pygame.Surface((sprite.width + 20, 20), pygame.SRCALPHA)
                pygame.draw.ellipse(s, (0,0,0,80), (0,0,sprite.width+20, 20))
                self.screen.blit(s, (sprite.rect.x - 10, sprite.rect.bottom - 10))
            elif isinstance(sprite, PalletCrateSprite) and sprite.rect.bottom == self.FLOOR_Y:
                if not self.forklift.cargo_sprite == sprite:
                    s = pygame.Surface((44, 10), pygame.SRCALPHA)
                    pygame.draw.ellipse(s, (0,0,0,60), (0,0,44,10))
                    self.screen.blit(s, (sprite.rect.x - 2, sprite.rect.bottom - 5))
        self.all_sprites.draw(self.screen)
        self.chassis.draw(self.screen)
        self.lcd.draw(self.screen)
        self.btn_write.draw(self.screen)
        self.btn_manifest.draw(self.screen)
        self.btn_clear.draw(self.screen)
        self.btn_resize.draw(self.screen)
        if self.show_manifest:
            self.draw_manifest()
</file>

<file path="FullStack Project Bible.ipynb/FullStack Project Bible.ipynb">
{
  "nbformat": 4,
  "nbformat_minor": 0,
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "name": "python3",
      "display_name": "Python 3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "cells": [
    {
      "cell_type": "markdown",
      "source": [
        "#  Project Design Document: \"Full Stack Logistics\"\n",
        "### CMPE 201: Data Structures Visualization Project\n",
        "**Theme:** Industrial Logistics Simulator / Warehouse Management\n",
        "**Engine:** Python + Pygame Community Edition (CE)\n",
        "**Tone:** \"Manage the Chaos. Deliver Efficiency.\"\n",
        "\n",
        "---\n"
      ],
      "metadata": {
        "id": "xPWqddUSvZOO"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## 1. Project Identity: \"Full Stack\"\n",
        "The name \"Full Stack\" is the unifying conceptual thread. We are not just building graphs; we are managing the logic behind a massive distribution center.\n",
        "\n",
        "*   **The Vibe:** *Factorio* meets *Euro Truck Simulator* meets *VS Code*.\n",
        "*   **The Metaphor:**\n",
        "    *   **Data** = Cargo (Crates, Containers, Trucks).\n",
        "    *   **Memory** = The Warehouse Floor.\n",
        "    *   **Pointers** = Tow Hitches / Conveyor Belts.\n",
        "    *   **Algorithms** = Automation Robots.\n",
        "\n",
        "---\n",
        "\n"
      ],
      "metadata": {
        "id": "-D3fO4BJvnnm"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## 2. Technical Architecture\n",
        "We will use the **Model-View-Controller (MVC)** pattern to ensure clean code for the panelists.\n",
        "\n",
        "### The Stack\n",
        "*   **Language:** Python 3.x\n",
        "*   **Graphics:** `pygame-ce` (for the Game Loop, sprites, and animation).\n",
        "*   **UI Elements:** `pygame_gui` (Optional, or custom built classes for clean input boxes).\n",
        "\n",
        "### Folder Structure\n",
        "```text\n",
        "Full_Stack_Sim/\n",
        "\n",
        " main.py                   # entry_point: Launches the \"Terminal\"\n",
        " settings.py               # config: Colors, Resolutions, Assets paths\n",
        "\n",
        " assets/                   # images: cargo.png, forklift.png, truck_sprite.png\n",
        "\n",
        " core/                     # VISUAL ENGINE\n",
        "    engine.py             # Pygame setup, Scene Manager\n",
        "    sprites.py            # Classes: Truck, Crate, Drone, Pallet\n",
        "    ui.py                 # Classes: TerminalButton, DataDisplay\n",
        "\n",
        " simulation/               # LOGIC MODULES (The \"Levels\")\n",
        "     site_parking_stack.py # STACK logic & visualization\n",
        "     site_parking_queue.py # QUEUE logic & visualization\n",
        "     site_warehouse_arr.py # ARRAYS logic & visualization\n",
        "     site_convoy_list.py   # LINKED LIST logic & visualization\n",
        "     site_sort_floor.py    # SORTING logic & visualization\n",
        "     site_router_tree.py   # BST logic & visualization\n",
        "     site_recursion_lab.py # RECURSION logic & visualization"
      ],
      "metadata": {
        "id": "NR9kuJg8vrZa"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "---\n",
        "## 3. Global Assets & Config\n",
        "\n",
        "**Visual Style Guide:**\n",
        "*   **Font:** *Courier New* or *Roboto Mono* (Terminal look).\n",
        "*   **Background:** `#2D3436` (Asphalt Grey).\n",
        "*   **Lines/UI:** `#FFEAA7` (Safety Yellow).\n",
        "*   **Accent (Active):** `#0984E3` (Blueprint Blue).\n",
        "*   **Accent (Error):** `#D63031` (Hazard Red).\n",
        "\n",
        "**Sprite Needs (2D Top-Down):**\n",
        "1.  **Truck:** Top-down view of a semi-cab.\n",
        "2.  **Container:** Rectangular box (various colors for Sorting).\n",
        "3.  **Forklift:** Small square sprite for Arrays.\n",
        "4.  **Diverter Node:** Circle with arrows for BST.\n",
        "\n",
        "---\n",
        "\n"
      ],
      "metadata": {
        "id": "08tWlpiwwMd4"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## 4. Module Specifications (The \"Levels\")\n",
        "\n",
        "### Level A: The \"Vertical Bay\" (Stack)\n",
        "*Goal: Manage a narrow, high-density maintenance bay.*\n",
        "\n",
        "*   **The Logic (LIFO):** Cars (Trucks) enter a one-way repair lane. Last truck in blocks the exit.\n",
        "*   **Visual Setup:** A vertical lane walls on Left/Right/Top. Entry is at the Bottom.\n",
        "*   **The \"Full Stack\" Mechanic (Departure):**\n",
        "    *   **User Action:** \"Release Truck Plate [XYZ] (blocked by 2 others)\".\n",
        "    *   **Animation Phase 1 (The Shuffle):** The 2 blocking trucks drive OUT into a \"Temporary Holding Zone\" drawn on the side.\n",
        "    *   **Animation Phase 2 (The Exit):** The target [XYZ] truck drives out and off-screen.\n",
        "    *   **Animation Phase 3 (The Restack):** The 2 blocking trucks drive back in from the Holding Zone to fill the gap.\n",
        "    *   *Why this works:* It visually proves the \"Pop\" cost of a Stack.\n",
        "\n",
        "### Level B: The \"Loopback Checkpoint\" (Queue)\n",
        "*Goal: Manage a Customs weigh station.*\n",
        "\n",
        "*   **The Logic (FIFO):** A horizontal lane. First truck enters -> First truck leaves.\n",
        "*   **Visual Setup:** Horizontal lane. Entrance (Left), Exit Gate (Right). **CRITICAL:** A U-turn road connects the Exit back to the Entrance.\n",
        "*   **The \"Blocked\" Mechanic:**\n",
        "    *   **User Action:** \"Expel Truck Plate [ABC] (Middle of line)\".\n",
        "    *   **Animation:** The front trucks depart the gate, take the U-turn road, and rejoin the back of the line (Cycling).\n",
        "    *   **Trigger:** Once [ABC] is at the front, the gate opens and it drives straight (off-screen) instead of taking the loop.\n",
        "\n",
        "### Level C: The \"Smart Rack\" (Arrays)\n",
        "*Goal: Automated shelving system.*\n",
        "\n",
        "*   **Visual Setup:** A long industrial shelf labeled Index 0-9.\n",
        "*   **Logic:**\n",
        "    *   **Insert:** A specialized Forklift travels to Index `i` and places a crate.\n",
        "    *   **Delete:** Forklift travels to Index `i` and removes crate.\n",
        "    *   **Access:** A spotlight scans horizontally until it hits Index `i` (flashing green).\n",
        "\n",
        "### Level D: The \"Convoy\" (Linked Lists)\n",
        "*Goal: Managing a chain of connected vehicles.*\n",
        "\n",
        "*   **Visual Setup:** Highway background. Trucks driving in a line.\n",
        "*   **Visualizing Pointers:** Draw a thick \"Cable\" or \"Hitch\" connecting the back of Truck A to the front of Truck B.\n",
        "*   **Logic (Insert Middle):**\n",
        "    *   Truck A disconnects cable from Truck B.\n",
        "    *   New Truck C drives into the gap.\n",
        "    *   Cable Connects A -> C.\n",
        "    *   Cable Connects C -> B.\n",
        "\n",
        "### Level E: The \"Sorter Belt\" (Sorting)\n",
        "*Goal: Organize containers by weight/height before shipping.*\n",
        "\n",
        "*   **Visual Setup:** A conveyor belt. Crates are rectangles of varying HEIGHTS (simulating values).\n",
        "*   **Animation (Bubble/Selection):**\n",
        "    *   Use a \"Gantry Crane\" (a rectangle above the crates).\n",
        "    *   When swapping two crates, smoothly slide them past each other (Don't teleport!).\n",
        "    *   **Status Colors:** Turn bars `Red` when comparing, `Green` when locked in place.\n",
        "\n",
        "### Level F: The \"Routing Floor\" (BST)\n",
        "*Goal: Automated package diverter system.*\n",
        "\n",
        "*   **Visual Setup:** Isometric view. \"Nodes\" are Circular Conveyor Junctions. \"Edges\" are Belts.\n",
        "*   **Interaction (Insertion):**\n",
        "    *   A package labeled \"50\" enters Root (Val 40).\n",
        "    *   Junction shows display: `50 > 40`.\n",
        "    *   Diverter Arm activates, pushing package to the RIGHT belt.\n",
        "*   **Interaction (Traversal):**\n",
        "    *   A \"System Drone\" flies over the belts. As it hovers over a junction (Node), the Node lights up White.\n",
        "    *   This sequence produces the print log (LRT, LTR, etc).\n",
        "\n",
        "### Level G: The \"Automation Lab\" (Recursion)\n",
        "*Goal: Experimental robotics.*\n",
        "\n",
        "1.  **Tower of Hanoi:**\n",
        "    *   **The \"Crane Game\":** Three cargo landing pads.\n",
        "    *   **Visuals:** Crates are stacked wide-to-narrow. A magnetic crane lifts them.\n",
        "    *   **Logic:** Recursion algorithm controls the crane coordinates.\n",
        "2.  **Factorial/Fib:**\n",
        "    *   **Visual:** \"Recursive Crates.\" A crate opens to reveal a smaller crate, which opens to reveal a smaller crate (Russian Nesting Doll style).\n",
        "\n",
        "---\n",
        "\n"
      ],
      "metadata": {
        "id": "FQv0VOY7xAgk"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## 5. Implementation Roadmap (Dev Plan)\n",
        "\n",
        "**Phase 1: The Frame (Days 1-2)**\n",
        "*   Build `main.py` window using Pygame.\n",
        "*   Create the \"Full Stack Management Terminal\" (Main Menu) using simple rect buttons.\n",
        "*   Create `Truck` sprite class.\n",
        "\n",
        "**Phase 2: The Core Parking (Days 3-4)**\n",
        "*   Implement `site_parking_stack.py`. **Priority:** Focus on the \"blocked car\" logic (moving to holding zone).\n",
        "*   Implement `site_parking_queue.py`. **Priority:** Focus on the \"Loopback\" animation.\n",
        "\n",
        "**Phase 3: The Structures (Days 5-6)**\n",
        "*   Linked List Convoy (visualizing the hitch connection).\n",
        "*   BST Conveyor Belts (visualizing the \"Right/Left\" choice).\n",
        "\n",
        "**Phase 4: Polish (Day 7)**\n",
        "*   Add the sound effects (Truck horns, hydraulic hisses).\n",
        "*   Add the Title Screen Logo: \"FULL STACK\" in ASCII or Pixel art.\n",
        "\n",
        "---\n"
      ],
      "metadata": {
        "id": "-_cygfuZxQKU"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "\n",
        "## 6. AI Generation Prompts\n",
        "*Use this specific system prompt when generating code to ensure consistency.*\n",
        "\n",
        "> * **Role:** You are the Lead Developer for a project called \"Full Stack Logistics.\"\n",
        "> * **Theme:** We are building a Pygame visualization where Data Structures are represented as Warehouse/Industrial operations.\n",
        "> * **Constraint:** Do not use `time.sleep()`. All movement must be incremental within the Pygame `while running` loop.\n",
        "> * **Architecture:** Use Class-based Logic. Logic (Python Class) must be decoupled from the Visualization (Sprite Class).\n",
        "> * **Task:** [Insert specific task here, e.g., \"Write the Queue Visualization where trucks loop back to the start if skipped.\"]"
      ],
      "metadata": {
        "id": "mKR9qTRPxU6w"
      }
    }
  ]
}
</file>

<file path="README.txt/README.txt">
PROJECT: Full Stack Logistics Simulator
VERSION: 1.0 (Gold Master)
THEME: Industrial Visualization of Data Structures (Warehouse Management System)
ENGINE: Python 3.x / Pygame Community Edition

DESCRIPTION:
A high-fidelity visualization tool that represents computer science data structures 
as realistic logistics operations. The project uses a "Sim-Style" aesthetic, 
rendering procedural assets (trucks, cargo, environment, buildings) entirely via code.

The experience begins at the "Facility Overview," a dynamic, procedurally generated 
industrial park at night, featuring real-time lighting and mechanical animations. 
Users "uplink" to specific facilities to interact with the underlying algorithms 
via a rugged handheld scanner interface.

CONTROLS:
- Mouse: Interact with UI, Select Slots, Hover over Facilities.
- Keyboard: Type values into the scanner.
- F11: Toggle Full Screen Mode.

MODULES (FACILITIES):

1. STACK TOWER (LIFO Operations)
   - Logic: Last-In, First-Out stack management.
   - Visuals: Vertical parking bay with hydraulic lifts and holding zones.

2. WEIGH STATION (FIFO Queue)
   - Logic: First-In, First-Out queue with loopback cycling.
   - Visuals: Industrial yard with animated conveyor lanes and traffic control.

3. CONVEYOR BELT (Linked List)
   - Logic: Singly Linked List (Insert/Remove at Index).
   - Visuals: Factory floor with volumetric lighting and animated belts.

4. ROUTING HUB (Binary Search Tree)
   - Logic: BST Insertion and Traversal (In/Pre/Post-order).
   - Visuals: Automated warehouse with drone-based package routing.

5. PARSER LAB (Expression Tree)
   - Logic: Shunting-yard algorithm for parsing mathematical expressions.
   - Visuals: High-tech analysis floor with processing grids.

6. SORTING YARD (Algorithms)
   - Logic: Bubble, Selection, Insertion, Merge, and Quick Sort.
   - Visuals: Large-scale gantry crane operations with container manipulation.

7. RECURSION LAB (Tower of Hanoi)
   - Logic: Recursive problem solving (Manual & Auto-Solve).
   - Visuals: Magnetic crane moving disks between platforms.

8. SMART RACK (Array Storage)
   - Logic: Fixed-size Array (O(1) Read vs O(n) Write).
   - Visuals: Multi-level pallet racking with industrial forklift physics.

DIRECTORY STRUCTURE:
Full_Stack_Sim/
 main.py                      # Entry Point (Facility Overview & State Machine)
 settings.py                  # Config, Palettes, Physics Constants
 core/                        # Shared Engine Code
    sprites.py               # Procedural Asset Generators (Trucks, Crates)
    ui.py                    # Rugged UI System (Scanner, Buttons)
 simulation/                  # Level Logic & Visualization
     site_parking_stack.py    # Stack Logic
     site_parking_queue.py    # Queue Logic
     site_conveyor_list.py    # Linked List Logic
     site_router_tree.py      # BST Logic
     site_expression_tree.py  # Expression Tree Logic
     site_sorting_floor.py    # Sorting Logic
     site_recursion_lab.py    # Recursion Logic
     site_warehouse_array.py  # Array Logic

HOW TO RUN:
1. Ensure Python 3.x and Pygame are installed (`pip install pygame`).
2. Run: `python main.py`
</file>

<file path="ROADMAP.txt/ROADMAP.txt">
PROJECT ROADMAP

PHASE 1: THE STACK (VERTICAL MAINTENANCE BAY) - [COMPLETED]
[x] Core Architecture (MVC Pattern).
[x] Logic: LIFO Stack with "Shuffle" algorithm.
[x] UI Overhaul: Integrated Rugged Handheld Interface.

PHASE 2: THE QUEUE (THE WEIGH STATION) - [COMPLETED]
[x] Logic: FIFO Queue with "Cycling" algorithm (Loopback).
[x] Visuals: High-Fidelity Industrial Yard with procedural props.

PHASE 3: LINKED LIST (THE CONVEYOR BELT) - [COMPLETED]
[x] Logic: Singly Linked List with Insert/Delete At Index.
[x] Visuals: High-detail warehouse with volumetric lighting.

PHASE 4: BST (THE ROUTING FLOOR) - [COMPLETED]
[x] Logic: Binary Search Tree insertion and traversals.
[x] Smart Layout: Implemented "Smooth Zoom" system.
[x] Feature: Traversal visualization with animated drone.

PHASE 5: BINARY TREE (THE EXPRESSION PARSER) - [COMPLETED]
[x] Logic: Shunting-yard algorithm and Tree generation.
[x] Feature: Pre/In/Post-order traversal analysis.

PHASE 6: SORTING ALGORITHMS (THE SORTING FLOOR) - [COMPLETED]
[x] Logic: Bubble, Selection, Insertion, Merge, Quick Sort.
[x] Visuals: Gantry Crane animation and Glow effects.

PHASE 7: RECURSION (THE AUTOMATION LAB) - [COMPLETED]
[x] Logic: Tower of Hanoi (Manual & Auto-Solve).
[x] Visuals: Magnetic Crane with dynamic hoist cable.

PHASE 8: ARRAYS (THE SMART RACK) - [COMPLETED]
[x] Logic: Fixed-size array with O(1) Read and O(n) Write/Clear simulation.
[x] Visuals: High-fidelity "Pallet Racking" environment.
[x] Animation: Industrial Forklift with complex lift/place physics.
[x] Feature: Dynamic Resizing (10-30 slots).

PHASE 9: FACILITY OVERVIEW (MAIN MENU) - [COMPLETED]
[x] Design: "Industrial Park" isometric map aesthetic.
[x] Visuals: Procedural 2.5D buildings, animated mechanical parts, dynamic lighting.
[x] Environment: Tiled concrete floor, asphalt roads, grime/oil textures.
[x] Interaction: Hover effects with spotlights and "System Uplink" transitions.

PHASE 10: FINAL POLISH - [COMPLETED]
[x] Full Screen Support (F11) with aspect ratio scaling.
[x] UI Refinement: High-contrast labels and consistent typography.
[x] Bug Fixes: Animation states, lighting artifacts, and layout adjustments.

---
PROJECT STATUS: COMPLETE (v1.0)
</file>

</files>
